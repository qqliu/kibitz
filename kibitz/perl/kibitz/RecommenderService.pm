#
# Autogenerated by Thrift Compiler (0.9.2)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
require 5.6.0;
use strict;
use warnings;
use Thrift;

use kibitz::Types;

# HELPER FUNCTIONS AND STRUCTURES

package kibitz::RecommenderService_createNewIndividualServer_args;
use base qw(Class::Accessor);
kibitz::RecommenderService_createNewIndividualServer_args->mk_accessors( qw( key ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{key} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RecommenderService_createNewIndividualServer_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecommenderService_createNewIndividualServer_args');
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', TType::STRING, 1);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package kibitz::RecommenderService_createNewIndividualServer_result;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'RecommenderService_createNewIndividualServer_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecommenderService_createNewIndividualServer_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package kibitz::RecommenderService_terminateSession_args;
use base qw(Class::Accessor);
kibitz::RecommenderService_terminateSession_args->mk_accessors( qw( key ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{key} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RecommenderService_terminateSession_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecommenderService_terminateSession_args');
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', TType::STRING, 1);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package kibitz::RecommenderService_terminateSession_result;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'RecommenderService_terminateSession_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecommenderService_terminateSession_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package kibitz::RecommenderService_makeRecommendation_args;
use base qw(Class::Accessor);
kibitz::RecommenderService_makeRecommendation_args->mk_accessors( qw( key userId numRecs isBoolean displayColumns ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{key} = undef;
  $self->{userId} = undef;
  $self->{numRecs} = undef;
  $self->{isBoolean} = undef;
  $self->{displayColumns} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{userId}) {
      $self->{userId} = $vals->{userId};
    }
    if (defined $vals->{numRecs}) {
      $self->{numRecs} = $vals->{numRecs};
    }
    if (defined $vals->{isBoolean}) {
      $self->{isBoolean} = $vals->{isBoolean};
    }
    if (defined $vals->{displayColumns}) {
      $self->{displayColumns} = $vals->{displayColumns};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RecommenderService_makeRecommendation_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{userId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{numRecs});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{isBoolean});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size25 = 0;
          $self->{displayColumns} = [];
          my $_etype28 = 0;
          $xfer += $input->readListBegin(\$_etype28, \$_size25);
          for (my $_i29 = 0; $_i29 < $_size25; ++$_i29)
          {
            my $elem30 = undef;
            $xfer += $input->readString(\$elem30);
            push(@{$self->{displayColumns}},$elem30);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecommenderService_makeRecommendation_args');
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', TType::STRING, 1);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userId}) {
    $xfer += $output->writeFieldBegin('userId', TType::I64, 2);
    $xfer += $output->writeI64($self->{userId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{numRecs}) {
    $xfer += $output->writeFieldBegin('numRecs', TType::I64, 3);
    $xfer += $output->writeI64($self->{numRecs});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{isBoolean}) {
    $xfer += $output->writeFieldBegin('isBoolean', TType::BOOL, 4);
    $xfer += $output->writeBool($self->{isBoolean});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{displayColumns}) {
    $xfer += $output->writeFieldBegin('displayColumns', TType::LIST, 5);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{displayColumns}}));
      {
        foreach my $iter31 (@{$self->{displayColumns}}) 
        {
          $xfer += $output->writeString($iter31);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package kibitz::RecommenderService_makeRecommendation_result;
use base qw(Class::Accessor);
kibitz::RecommenderService_makeRecommendation_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RecommenderService_makeRecommendation_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size32 = 0;
          $self->{success} = [];
          my $_etype35 = 0;
          $xfer += $input->readListBegin(\$_etype35, \$_size32);
          for (my $_i36 = 0; $_i36 < $_size32; ++$_i36)
          {
            my $elem37 = undef;
            $elem37 = new kibitz::Item();
            $xfer += $elem37->read($input);
            push(@{$self->{success}},$elem37);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecommenderService_makeRecommendation_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter38 (@{$self->{success}}) 
        {
          $xfer += ${iter38}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package kibitz::RecommenderService_makeItemBasedRecommendations_args;
use base qw(Class::Accessor);
kibitz::RecommenderService_makeItemBasedRecommendations_args->mk_accessors( qw( key userId numRecs displayColumns ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{key} = undef;
  $self->{userId} = undef;
  $self->{numRecs} = undef;
  $self->{displayColumns} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{userId}) {
      $self->{userId} = $vals->{userId};
    }
    if (defined $vals->{numRecs}) {
      $self->{numRecs} = $vals->{numRecs};
    }
    if (defined $vals->{displayColumns}) {
      $self->{displayColumns} = $vals->{displayColumns};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RecommenderService_makeItemBasedRecommendations_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{userId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{numRecs});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size39 = 0;
          $self->{displayColumns} = [];
          my $_etype42 = 0;
          $xfer += $input->readListBegin(\$_etype42, \$_size39);
          for (my $_i43 = 0; $_i43 < $_size39; ++$_i43)
          {
            my $elem44 = undef;
            $xfer += $input->readString(\$elem44);
            push(@{$self->{displayColumns}},$elem44);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecommenderService_makeItemBasedRecommendations_args');
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', TType::STRING, 1);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userId}) {
    $xfer += $output->writeFieldBegin('userId', TType::I64, 2);
    $xfer += $output->writeI64($self->{userId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{numRecs}) {
    $xfer += $output->writeFieldBegin('numRecs', TType::I64, 3);
    $xfer += $output->writeI64($self->{numRecs});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{displayColumns}) {
    $xfer += $output->writeFieldBegin('displayColumns', TType::LIST, 4);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{displayColumns}}));
      {
        foreach my $iter45 (@{$self->{displayColumns}}) 
        {
          $xfer += $output->writeString($iter45);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package kibitz::RecommenderService_makeItemBasedRecommendations_result;
use base qw(Class::Accessor);
kibitz::RecommenderService_makeItemBasedRecommendations_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RecommenderService_makeItemBasedRecommendations_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size46 = 0;
          $self->{success} = [];
          my $_etype49 = 0;
          $xfer += $input->readListBegin(\$_etype49, \$_size46);
          for (my $_i50 = 0; $_i50 < $_size46; ++$_i50)
          {
            my $elem51 = undef;
            $elem51 = new kibitz::Item();
            $xfer += $elem51->read($input);
            push(@{$self->{success}},$elem51);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecommenderService_makeItemBasedRecommendations_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter52 (@{$self->{success}}) 
        {
          $xfer += ${iter52}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package kibitz::RecommenderService_getPageItems_args;
use base qw(Class::Accessor);
kibitz::RecommenderService_getPageItems_args->mk_accessors( qw( key page numPerPage displayColumns ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{key} = undef;
  $self->{page} = undef;
  $self->{numPerPage} = undef;
  $self->{displayColumns} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{page}) {
      $self->{page} = $vals->{page};
    }
    if (defined $vals->{numPerPage}) {
      $self->{numPerPage} = $vals->{numPerPage};
    }
    if (defined $vals->{displayColumns}) {
      $self->{displayColumns} = $vals->{displayColumns};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RecommenderService_getPageItems_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{page});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{numPerPage});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size53 = 0;
          $self->{displayColumns} = [];
          my $_etype56 = 0;
          $xfer += $input->readListBegin(\$_etype56, \$_size53);
          for (my $_i57 = 0; $_i57 < $_size53; ++$_i57)
          {
            my $elem58 = undef;
            $xfer += $input->readString(\$elem58);
            push(@{$self->{displayColumns}},$elem58);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecommenderService_getPageItems_args');
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', TType::STRING, 1);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{page}) {
    $xfer += $output->writeFieldBegin('page', TType::I64, 2);
    $xfer += $output->writeI64($self->{page});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{numPerPage}) {
    $xfer += $output->writeFieldBegin('numPerPage', TType::I64, 3);
    $xfer += $output->writeI64($self->{numPerPage});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{displayColumns}) {
    $xfer += $output->writeFieldBegin('displayColumns', TType::LIST, 4);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{displayColumns}}));
      {
        foreach my $iter59 (@{$self->{displayColumns}}) 
        {
          $xfer += $output->writeString($iter59);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package kibitz::RecommenderService_getPageItems_result;
use base qw(Class::Accessor);
kibitz::RecommenderService_getPageItems_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RecommenderService_getPageItems_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size60 = 0;
          $self->{success} = [];
          my $_etype63 = 0;
          $xfer += $input->readListBegin(\$_etype63, \$_size60);
          for (my $_i64 = 0; $_i64 < $_size60; ++$_i64)
          {
            my $elem65 = undef;
            $elem65 = new kibitz::Item();
            $xfer += $elem65->read($input);
            push(@{$self->{success}},$elem65);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecommenderService_getPageItems_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter66 (@{$self->{success}}) 
        {
          $xfer += ${iter66}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package kibitz::RecommenderService_getItemCount_args;
use base qw(Class::Accessor);
kibitz::RecommenderService_getItemCount_args->mk_accessors( qw( key ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{key} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RecommenderService_getItemCount_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecommenderService_getItemCount_args');
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', TType::STRING, 1);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package kibitz::RecommenderService_getItemCount_result;
use base qw(Class::Accessor);
kibitz::RecommenderService_getItemCount_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RecommenderService_getItemCount_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecommenderService_getItemCount_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I64, 0);
    $xfer += $output->writeI64($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package kibitz::RecommenderService_recordRatings_args;
use base qw(Class::Accessor);
kibitz::RecommenderService_recordRatings_args->mk_accessors( qw( key userId itemId rating ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{key} = undef;
  $self->{userId} = undef;
  $self->{itemId} = undef;
  $self->{rating} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{userId}) {
      $self->{userId} = $vals->{userId};
    }
    if (defined $vals->{itemId}) {
      $self->{itemId} = $vals->{itemId};
    }
    if (defined $vals->{rating}) {
      $self->{rating} = $vals->{rating};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RecommenderService_recordRatings_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{userId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{itemId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{rating});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecommenderService_recordRatings_args');
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', TType::STRING, 1);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userId}) {
    $xfer += $output->writeFieldBegin('userId', TType::I64, 2);
    $xfer += $output->writeI64($self->{userId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{itemId}) {
    $xfer += $output->writeFieldBegin('itemId', TType::I64, 3);
    $xfer += $output->writeI64($self->{itemId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{rating}) {
    $xfer += $output->writeFieldBegin('rating', TType::I64, 4);
    $xfer += $output->writeI64($self->{rating});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package kibitz::RecommenderService_recordRatings_result;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'RecommenderService_recordRatings_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecommenderService_recordRatings_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package kibitz::RecommenderService_deleteRatings_args;
use base qw(Class::Accessor);
kibitz::RecommenderService_deleteRatings_args->mk_accessors( qw( key userId itemId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{key} = undef;
  $self->{userId} = undef;
  $self->{itemId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{userId}) {
      $self->{userId} = $vals->{userId};
    }
    if (defined $vals->{itemId}) {
      $self->{itemId} = $vals->{itemId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RecommenderService_deleteRatings_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{userId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{itemId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecommenderService_deleteRatings_args');
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', TType::STRING, 1);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userId}) {
    $xfer += $output->writeFieldBegin('userId', TType::I64, 2);
    $xfer += $output->writeI64($self->{userId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{itemId}) {
    $xfer += $output->writeFieldBegin('itemId', TType::I64, 3);
    $xfer += $output->writeI64($self->{itemId});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package kibitz::RecommenderService_deleteRatings_result;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'RecommenderService_deleteRatings_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecommenderService_deleteRatings_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package kibitz::RecommenderService_createNewUser_args;
use base qw(Class::Accessor);
kibitz::RecommenderService_createNewUser_args->mk_accessors( qw( key username iskibitzuser ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{key} = undef;
  $self->{username} = undef;
  $self->{iskibitzuser} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{username}) {
      $self->{username} = $vals->{username};
    }
    if (defined $vals->{iskibitzuser}) {
      $self->{iskibitzuser} = $vals->{iskibitzuser};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RecommenderService_createNewUser_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{username});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{iskibitzuser});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecommenderService_createNewUser_args');
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', TType::STRING, 1);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{username}) {
    $xfer += $output->writeFieldBegin('username', TType::STRING, 2);
    $xfer += $output->writeString($self->{username});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{iskibitzuser}) {
    $xfer += $output->writeFieldBegin('iskibitzuser', TType::BOOL, 3);
    $xfer += $output->writeBool($self->{iskibitzuser});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package kibitz::RecommenderService_createNewUser_result;
use base qw(Class::Accessor);
kibitz::RecommenderService_createNewUser_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RecommenderService_createNewUser_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecommenderService_createNewUser_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package kibitz::RecommenderService_checkUsername_args;
use base qw(Class::Accessor);
kibitz::RecommenderService_checkUsername_args->mk_accessors( qw( key username iskibitzuser ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{key} = undef;
  $self->{username} = undef;
  $self->{iskibitzuser} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{username}) {
      $self->{username} = $vals->{username};
    }
    if (defined $vals->{iskibitzuser}) {
      $self->{iskibitzuser} = $vals->{iskibitzuser};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RecommenderService_checkUsername_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{username});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{iskibitzuser});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecommenderService_checkUsername_args');
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', TType::STRING, 1);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{username}) {
    $xfer += $output->writeFieldBegin('username', TType::STRING, 2);
    $xfer += $output->writeString($self->{username});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{iskibitzuser}) {
    $xfer += $output->writeFieldBegin('iskibitzuser', TType::BOOL, 3);
    $xfer += $output->writeBool($self->{iskibitzuser});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package kibitz::RecommenderService_checkUsername_result;
use base qw(Class::Accessor);
kibitz::RecommenderService_checkUsername_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RecommenderService_checkUsername_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecommenderService_checkUsername_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package kibitz::RecommenderService_checkLogin_args;
use base qw(Class::Accessor);
kibitz::RecommenderService_checkLogin_args->mk_accessors( qw( key username password iskibitzuser ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{key} = undef;
  $self->{username} = undef;
  $self->{password} = undef;
  $self->{iskibitzuser} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{username}) {
      $self->{username} = $vals->{username};
    }
    if (defined $vals->{password}) {
      $self->{password} = $vals->{password};
    }
    if (defined $vals->{iskibitzuser}) {
      $self->{iskibitzuser} = $vals->{iskibitzuser};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RecommenderService_checkLogin_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{username});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{password});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{iskibitzuser});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecommenderService_checkLogin_args');
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', TType::STRING, 1);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{username}) {
    $xfer += $output->writeFieldBegin('username', TType::STRING, 2);
    $xfer += $output->writeString($self->{username});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{password}) {
    $xfer += $output->writeFieldBegin('password', TType::STRING, 3);
    $xfer += $output->writeString($self->{password});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{iskibitzuser}) {
    $xfer += $output->writeFieldBegin('iskibitzuser', TType::BOOL, 4);
    $xfer += $output->writeBool($self->{iskibitzuser});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package kibitz::RecommenderService_checkLogin_result;
use base qw(Class::Accessor);
kibitz::RecommenderService_checkLogin_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RecommenderService_checkLogin_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecommenderService_checkLogin_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package kibitz::RecommenderService_retrieveUserId_args;
use base qw(Class::Accessor);
kibitz::RecommenderService_retrieveUserId_args->mk_accessors( qw( key username ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{key} = undef;
  $self->{username} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{username}) {
      $self->{username} = $vals->{username};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RecommenderService_retrieveUserId_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{username});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecommenderService_retrieveUserId_args');
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', TType::STRING, 1);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{username}) {
    $xfer += $output->writeFieldBegin('username', TType::STRING, 2);
    $xfer += $output->writeString($self->{username});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package kibitz::RecommenderService_retrieveUserId_result;
use base qw(Class::Accessor);
kibitz::RecommenderService_retrieveUserId_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RecommenderService_retrieveUserId_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecommenderService_retrieveUserId_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I64, 0);
    $xfer += $output->writeI64($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package kibitz::RecommenderService_createNewRecommender_args;
use base qw(Class::Accessor);
kibitz::RecommenderService_createNewRecommender_args->mk_accessors( qw( username primaryKey database table title description image ratings_column clientKey ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{username} = undef;
  $self->{primaryKey} = undef;
  $self->{database} = undef;
  $self->{table} = undef;
  $self->{title} = undef;
  $self->{description} = undef;
  $self->{image} = undef;
  $self->{ratings_column} = undef;
  $self->{clientKey} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{username}) {
      $self->{username} = $vals->{username};
    }
    if (defined $vals->{primaryKey}) {
      $self->{primaryKey} = $vals->{primaryKey};
    }
    if (defined $vals->{database}) {
      $self->{database} = $vals->{database};
    }
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{title}) {
      $self->{title} = $vals->{title};
    }
    if (defined $vals->{description}) {
      $self->{description} = $vals->{description};
    }
    if (defined $vals->{image}) {
      $self->{image} = $vals->{image};
    }
    if (defined $vals->{ratings_column}) {
      $self->{ratings_column} = $vals->{ratings_column};
    }
    if (defined $vals->{clientKey}) {
      $self->{clientKey} = $vals->{clientKey};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RecommenderService_createNewRecommender_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{username});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{primaryKey});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{database});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{title});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{description});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^8$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{image});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^9$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{ratings_column});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^10$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{clientKey});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecommenderService_createNewRecommender_args');
  if (defined $self->{username}) {
    $xfer += $output->writeFieldBegin('username', TType::STRING, 1);
    $xfer += $output->writeString($self->{username});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{primaryKey}) {
    $xfer += $output->writeFieldBegin('primaryKey', TType::STRING, 2);
    $xfer += $output->writeString($self->{primaryKey});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{database}) {
    $xfer += $output->writeFieldBegin('database', TType::STRING, 3);
    $xfer += $output->writeString($self->{database});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 5);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{title}) {
    $xfer += $output->writeFieldBegin('title', TType::STRING, 6);
    $xfer += $output->writeString($self->{title});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{description}) {
    $xfer += $output->writeFieldBegin('description', TType::STRING, 7);
    $xfer += $output->writeString($self->{description});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{image}) {
    $xfer += $output->writeFieldBegin('image', TType::STRING, 8);
    $xfer += $output->writeString($self->{image});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ratings_column}) {
    $xfer += $output->writeFieldBegin('ratings_column', TType::STRING, 9);
    $xfer += $output->writeString($self->{ratings_column});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{clientKey}) {
    $xfer += $output->writeFieldBegin('clientKey', TType::STRING, 10);
    $xfer += $output->writeString($self->{clientKey});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package kibitz::RecommenderService_createNewRecommender_result;
use base qw(Class::Accessor);
kibitz::RecommenderService_createNewRecommender_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RecommenderService_createNewRecommender_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecommenderService_createNewRecommender_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package kibitz::RecommenderService_getUserRatedItems_args;
use base qw(Class::Accessor);
kibitz::RecommenderService_getUserRatedItems_args->mk_accessors( qw( key userId displayColumns ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{key} = undef;
  $self->{userId} = undef;
  $self->{displayColumns} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{userId}) {
      $self->{userId} = $vals->{userId};
    }
    if (defined $vals->{displayColumns}) {
      $self->{displayColumns} = $vals->{displayColumns};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RecommenderService_getUserRatedItems_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{userId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size67 = 0;
          $self->{displayColumns} = [];
          my $_etype70 = 0;
          $xfer += $input->readListBegin(\$_etype70, \$_size67);
          for (my $_i71 = 0; $_i71 < $_size67; ++$_i71)
          {
            my $elem72 = undef;
            $xfer += $input->readString(\$elem72);
            push(@{$self->{displayColumns}},$elem72);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecommenderService_getUserRatedItems_args');
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', TType::STRING, 1);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userId}) {
    $xfer += $output->writeFieldBegin('userId', TType::I64, 2);
    $xfer += $output->writeI64($self->{userId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{displayColumns}) {
    $xfer += $output->writeFieldBegin('displayColumns', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{displayColumns}}));
      {
        foreach my $iter73 (@{$self->{displayColumns}}) 
        {
          $xfer += $output->writeString($iter73);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package kibitz::RecommenderService_getUserRatedItems_result;
use base qw(Class::Accessor);
kibitz::RecommenderService_getUserRatedItems_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RecommenderService_getUserRatedItems_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size74 = 0;
          $self->{success} = [];
          my $_etype77 = 0;
          $xfer += $input->readListBegin(\$_etype77, \$_size74);
          for (my $_i78 = 0; $_i78 < $_size74; ++$_i78)
          {
            my $elem79 = undef;
            $elem79 = new kibitz::Item();
            $xfer += $elem79->read($input);
            push(@{$self->{success}},$elem79);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecommenderService_getUserRatedItems_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter80 (@{$self->{success}}) 
        {
          $xfer += ${iter80}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package kibitz::RecommenderService_initiateModel_args;
use base qw(Class::Accessor);
kibitz::RecommenderService_initiateModel_args->mk_accessors( qw( key table username database ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{key} = undef;
  $self->{table} = undef;
  $self->{username} = undef;
  $self->{database} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{username}) {
      $self->{username} = $vals->{username};
    }
    if (defined $vals->{database}) {
      $self->{database} = $vals->{database};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RecommenderService_initiateModel_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{username});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{database});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecommenderService_initiateModel_args');
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', TType::STRING, 1);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 2);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{username}) {
    $xfer += $output->writeFieldBegin('username', TType::STRING, 3);
    $xfer += $output->writeString($self->{username});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{database}) {
    $xfer += $output->writeFieldBegin('database', TType::STRING, 4);
    $xfer += $output->writeString($self->{database});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package kibitz::RecommenderService_initiateModel_result;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'RecommenderService_initiateModel_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecommenderService_initiateModel_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package kibitz::RecommenderService_getSearchItems_args;
use base qw(Class::Accessor);
kibitz::RecommenderService_getSearchItems_args->mk_accessors( qw( table query columnsToSearch displayColumns ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  $self->{query} = undef;
  $self->{columnsToSearch} = undef;
  $self->{displayColumns} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{query}) {
      $self->{query} = $vals->{query};
    }
    if (defined $vals->{columnsToSearch}) {
      $self->{columnsToSearch} = $vals->{columnsToSearch};
    }
    if (defined $vals->{displayColumns}) {
      $self->{displayColumns} = $vals->{displayColumns};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RecommenderService_getSearchItems_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{query});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size81 = 0;
          $self->{columnsToSearch} = [];
          my $_etype84 = 0;
          $xfer += $input->readListBegin(\$_etype84, \$_size81);
          for (my $_i85 = 0; $_i85 < $_size81; ++$_i85)
          {
            my $elem86 = undef;
            $xfer += $input->readString(\$elem86);
            push(@{$self->{columnsToSearch}},$elem86);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size87 = 0;
          $self->{displayColumns} = [];
          my $_etype90 = 0;
          $xfer += $input->readListBegin(\$_etype90, \$_size87);
          for (my $_i91 = 0; $_i91 < $_size87; ++$_i91)
          {
            my $elem92 = undef;
            $xfer += $input->readString(\$elem92);
            push(@{$self->{displayColumns}},$elem92);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecommenderService_getSearchItems_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{query}) {
    $xfer += $output->writeFieldBegin('query', TType::STRING, 2);
    $xfer += $output->writeString($self->{query});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columnsToSearch}) {
    $xfer += $output->writeFieldBegin('columnsToSearch', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{columnsToSearch}}));
      {
        foreach my $iter93 (@{$self->{columnsToSearch}}) 
        {
          $xfer += $output->writeString($iter93);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{displayColumns}) {
    $xfer += $output->writeFieldBegin('displayColumns', TType::LIST, 4);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{displayColumns}}));
      {
        foreach my $iter94 (@{$self->{displayColumns}}) 
        {
          $xfer += $output->writeString($iter94);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package kibitz::RecommenderService_getSearchItems_result;
use base qw(Class::Accessor);
kibitz::RecommenderService_getSearchItems_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RecommenderService_getSearchItems_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size95 = 0;
          $self->{success} = [];
          my $_etype98 = 0;
          $xfer += $input->readListBegin(\$_etype98, \$_size95);
          for (my $_i99 = 0; $_i99 < $_size95; ++$_i99)
          {
            my $elem100 = undef;
            $elem100 = new kibitz::Item();
            $xfer += $elem100->read($input);
            push(@{$self->{success}},$elem100);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecommenderService_getSearchItems_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter101 (@{$self->{success}}) 
        {
          $xfer += ${iter101}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package kibitz::RecommenderService_makeOverallRatingBasedOrRandomRecommendation_args;
use base qw(Class::Accessor);
kibitz::RecommenderService_makeOverallRatingBasedOrRandomRecommendation_args->mk_accessors( qw( key ratingColumnName numRecs displayColumns ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{key} = undef;
  $self->{ratingColumnName} = undef;
  $self->{numRecs} = undef;
  $self->{displayColumns} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{ratingColumnName}) {
      $self->{ratingColumnName} = $vals->{ratingColumnName};
    }
    if (defined $vals->{numRecs}) {
      $self->{numRecs} = $vals->{numRecs};
    }
    if (defined $vals->{displayColumns}) {
      $self->{displayColumns} = $vals->{displayColumns};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RecommenderService_makeOverallRatingBasedOrRandomRecommendation_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{ratingColumnName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{numRecs});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size102 = 0;
          $self->{displayColumns} = [];
          my $_etype105 = 0;
          $xfer += $input->readListBegin(\$_etype105, \$_size102);
          for (my $_i106 = 0; $_i106 < $_size102; ++$_i106)
          {
            my $elem107 = undef;
            $xfer += $input->readString(\$elem107);
            push(@{$self->{displayColumns}},$elem107);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecommenderService_makeOverallRatingBasedOrRandomRecommendation_args');
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', TType::STRING, 1);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ratingColumnName}) {
    $xfer += $output->writeFieldBegin('ratingColumnName', TType::STRING, 2);
    $xfer += $output->writeString($self->{ratingColumnName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{numRecs}) {
    $xfer += $output->writeFieldBegin('numRecs', TType::I64, 3);
    $xfer += $output->writeI64($self->{numRecs});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{displayColumns}) {
    $xfer += $output->writeFieldBegin('displayColumns', TType::LIST, 4);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{displayColumns}}));
      {
        foreach my $iter108 (@{$self->{displayColumns}}) 
        {
          $xfer += $output->writeString($iter108);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package kibitz::RecommenderService_makeOverallRatingBasedOrRandomRecommendation_result;
use base qw(Class::Accessor);
kibitz::RecommenderService_makeOverallRatingBasedOrRandomRecommendation_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RecommenderService_makeOverallRatingBasedOrRandomRecommendation_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size109 = 0;
          $self->{success} = [];
          my $_etype112 = 0;
          $xfer += $input->readListBegin(\$_etype112, \$_size109);
          for (my $_i113 = 0; $_i113 < $_size109; ++$_i113)
          {
            my $elem114 = undef;
            $elem114 = new kibitz::Item();
            $xfer += $elem114->read($input);
            push(@{$self->{success}},$elem114);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecommenderService_makeOverallRatingBasedOrRandomRecommendation_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter115 (@{$self->{success}}) 
        {
          $xfer += ${iter115}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package kibitz::RecommenderService_addKibitzUser_args;
use base qw(Class::Accessor);
kibitz::RecommenderService_addKibitzUser_args->mk_accessors( qw( email password ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{email} = undef;
  $self->{password} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{email}) {
      $self->{email} = $vals->{email};
    }
    if (defined $vals->{password}) {
      $self->{password} = $vals->{password};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RecommenderService_addKibitzUser_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{email});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{password});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecommenderService_addKibitzUser_args');
  if (defined $self->{email}) {
    $xfer += $output->writeFieldBegin('email', TType::STRING, 1);
    $xfer += $output->writeString($self->{email});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{password}) {
    $xfer += $output->writeFieldBegin('password', TType::STRING, 2);
    $xfer += $output->writeString($self->{password});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package kibitz::RecommenderService_addKibitzUser_result;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'RecommenderService_addKibitzUser_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecommenderService_addKibitzUser_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package kibitz::RecommenderService_checkCorrectDatahubLogin_args;
use base qw(Class::Accessor);
kibitz::RecommenderService_checkCorrectDatahubLogin_args->mk_accessors( qw( username repository table primary_key title description image ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{username} = undef;
  $self->{repository} = undef;
  $self->{table} = undef;
  $self->{primary_key} = undef;
  $self->{title} = undef;
  $self->{description} = undef;
  $self->{image} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{username}) {
      $self->{username} = $vals->{username};
    }
    if (defined $vals->{repository}) {
      $self->{repository} = $vals->{repository};
    }
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{primary_key}) {
      $self->{primary_key} = $vals->{primary_key};
    }
    if (defined $vals->{title}) {
      $self->{title} = $vals->{title};
    }
    if (defined $vals->{description}) {
      $self->{description} = $vals->{description};
    }
    if (defined $vals->{image}) {
      $self->{image} = $vals->{image};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RecommenderService_checkCorrectDatahubLogin_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{username});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{repository});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{primary_key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{title});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{description});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{image});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecommenderService_checkCorrectDatahubLogin_args');
  if (defined $self->{username}) {
    $xfer += $output->writeFieldBegin('username', TType::STRING, 1);
    $xfer += $output->writeString($self->{username});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{repository}) {
    $xfer += $output->writeFieldBegin('repository', TType::STRING, 2);
    $xfer += $output->writeString($self->{repository});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 3);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{primary_key}) {
    $xfer += $output->writeFieldBegin('primary_key', TType::STRING, 4);
    $xfer += $output->writeString($self->{primary_key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{title}) {
    $xfer += $output->writeFieldBegin('title', TType::STRING, 5);
    $xfer += $output->writeString($self->{title});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{description}) {
    $xfer += $output->writeFieldBegin('description', TType::STRING, 6);
    $xfer += $output->writeString($self->{description});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{image}) {
    $xfer += $output->writeFieldBegin('image', TType::STRING, 7);
    $xfer += $output->writeString($self->{image});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package kibitz::RecommenderService_checkCorrectDatahubLogin_result;
use base qw(Class::Accessor);
kibitz::RecommenderService_checkCorrectDatahubLogin_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RecommenderService_checkCorrectDatahubLogin_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecommenderService_checkCorrectDatahubLogin_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package kibitz::RecommenderService_checkRatingsColumn_args;
use base qw(Class::Accessor);
kibitz::RecommenderService_checkRatingsColumn_args->mk_accessors( qw( username table repository ratings_column ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{username} = undef;
  $self->{table} = undef;
  $self->{repository} = undef;
  $self->{ratings_column} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{username}) {
      $self->{username} = $vals->{username};
    }
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{repository}) {
      $self->{repository} = $vals->{repository};
    }
    if (defined $vals->{ratings_column}) {
      $self->{ratings_column} = $vals->{ratings_column};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RecommenderService_checkRatingsColumn_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{username});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{repository});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{ratings_column});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecommenderService_checkRatingsColumn_args');
  if (defined $self->{username}) {
    $xfer += $output->writeFieldBegin('username', TType::STRING, 1);
    $xfer += $output->writeString($self->{username});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 2);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{repository}) {
    $xfer += $output->writeFieldBegin('repository', TType::STRING, 3);
    $xfer += $output->writeString($self->{repository});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ratings_column}) {
    $xfer += $output->writeFieldBegin('ratings_column', TType::STRING, 4);
    $xfer += $output->writeString($self->{ratings_column});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package kibitz::RecommenderService_checkRatingsColumn_result;
use base qw(Class::Accessor);
kibitz::RecommenderService_checkRatingsColumn_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RecommenderService_checkRatingsColumn_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecommenderService_checkRatingsColumn_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package kibitz::RecommenderService_getRecommenders_args;
use base qw(Class::Accessor);
kibitz::RecommenderService_getRecommenders_args->mk_accessors( qw( username ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{username} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{username}) {
      $self->{username} = $vals->{username};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RecommenderService_getRecommenders_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{username});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecommenderService_getRecommenders_args');
  if (defined $self->{username}) {
    $xfer += $output->writeFieldBegin('username', TType::STRING, 1);
    $xfer += $output->writeString($self->{username});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package kibitz::RecommenderService_getRecommenders_result;
use base qw(Class::Accessor);
kibitz::RecommenderService_getRecommenders_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RecommenderService_getRecommenders_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size116 = 0;
          $self->{success} = [];
          my $_etype119 = 0;
          $xfer += $input->readListBegin(\$_etype119, \$_size116);
          for (my $_i120 = 0; $_i120 < $_size116; ++$_i120)
          {
            my $elem121 = undef;
            $elem121 = new kibitz::Recommender();
            $xfer += $elem121->read($input);
            push(@{$self->{success}},$elem121);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecommenderService_getRecommenders_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter122 (@{$self->{success}}) 
        {
          $xfer += ${iter122}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package kibitz::RecommenderService_getProfilePicture_args;
use base qw(Class::Accessor);
kibitz::RecommenderService_getProfilePicture_args->mk_accessors( qw( username ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{username} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{username}) {
      $self->{username} = $vals->{username};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RecommenderService_getProfilePicture_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{username});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecommenderService_getProfilePicture_args');
  if (defined $self->{username}) {
    $xfer += $output->writeFieldBegin('username', TType::STRING, 1);
    $xfer += $output->writeString($self->{username});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package kibitz::RecommenderService_getProfilePicture_result;
use base qw(Class::Accessor);
kibitz::RecommenderService_getProfilePicture_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RecommenderService_getProfilePicture_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecommenderService_getProfilePicture_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package kibitz::RecommenderService_saveFBProfilePic_args;
use base qw(Class::Accessor);
kibitz::RecommenderService_saveFBProfilePic_args->mk_accessors( qw( username fbUsername ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{username} = undef;
  $self->{fbUsername} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{username}) {
      $self->{username} = $vals->{username};
    }
    if (defined $vals->{fbUsername}) {
      $self->{fbUsername} = $vals->{fbUsername};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RecommenderService_saveFBProfilePic_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{username});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{fbUsername});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecommenderService_saveFBProfilePic_args');
  if (defined $self->{username}) {
    $xfer += $output->writeFieldBegin('username', TType::STRING, 1);
    $xfer += $output->writeString($self->{username});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{fbUsername}) {
    $xfer += $output->writeFieldBegin('fbUsername', TType::STRING, 2);
    $xfer += $output->writeString($self->{fbUsername});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package kibitz::RecommenderService_saveFBProfilePic_result;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'RecommenderService_saveFBProfilePic_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecommenderService_saveFBProfilePic_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package kibitz::RecommenderService_deleteRecommender_args;
use base qw(Class::Accessor);
kibitz::RecommenderService_deleteRecommender_args->mk_accessors( qw( clientKey ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{clientKey} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{clientKey}) {
      $self->{clientKey} = $vals->{clientKey};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RecommenderService_deleteRecommender_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{clientKey});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecommenderService_deleteRecommender_args');
  if (defined $self->{clientKey}) {
    $xfer += $output->writeFieldBegin('clientKey', TType::STRING, 1);
    $xfer += $output->writeString($self->{clientKey});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package kibitz::RecommenderService_deleteRecommender_result;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'RecommenderService_deleteRecommender_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecommenderService_deleteRecommender_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package kibitz::RecommenderService_updateTemplate_args;
use base qw(Class::Accessor);
kibitz::RecommenderService_updateTemplate_args->mk_accessors( qw( username primaryKey title description image video itemTypes displayItems maxRatingVal numRecs recommenderName clientKey homepage creatorName repoName tableName ratingsColumn ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{username} = undef;
  $self->{primaryKey} = undef;
  $self->{title} = undef;
  $self->{description} = undef;
  $self->{image} = undef;
  $self->{video} = undef;
  $self->{itemTypes} = undef;
  $self->{displayItems} = undef;
  $self->{maxRatingVal} = undef;
  $self->{numRecs} = undef;
  $self->{recommenderName} = undef;
  $self->{clientKey} = undef;
  $self->{homepage} = undef;
  $self->{creatorName} = undef;
  $self->{repoName} = undef;
  $self->{tableName} = undef;
  $self->{ratingsColumn} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{username}) {
      $self->{username} = $vals->{username};
    }
    if (defined $vals->{primaryKey}) {
      $self->{primaryKey} = $vals->{primaryKey};
    }
    if (defined $vals->{title}) {
      $self->{title} = $vals->{title};
    }
    if (defined $vals->{description}) {
      $self->{description} = $vals->{description};
    }
    if (defined $vals->{image}) {
      $self->{image} = $vals->{image};
    }
    if (defined $vals->{video}) {
      $self->{video} = $vals->{video};
    }
    if (defined $vals->{itemTypes}) {
      $self->{itemTypes} = $vals->{itemTypes};
    }
    if (defined $vals->{displayItems}) {
      $self->{displayItems} = $vals->{displayItems};
    }
    if (defined $vals->{maxRatingVal}) {
      $self->{maxRatingVal} = $vals->{maxRatingVal};
    }
    if (defined $vals->{numRecs}) {
      $self->{numRecs} = $vals->{numRecs};
    }
    if (defined $vals->{recommenderName}) {
      $self->{recommenderName} = $vals->{recommenderName};
    }
    if (defined $vals->{clientKey}) {
      $self->{clientKey} = $vals->{clientKey};
    }
    if (defined $vals->{homepage}) {
      $self->{homepage} = $vals->{homepage};
    }
    if (defined $vals->{creatorName}) {
      $self->{creatorName} = $vals->{creatorName};
    }
    if (defined $vals->{repoName}) {
      $self->{repoName} = $vals->{repoName};
    }
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{ratingsColumn}) {
      $self->{ratingsColumn} = $vals->{ratingsColumn};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RecommenderService_updateTemplate_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{username});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{primaryKey});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{title});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{description});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{image});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{video});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size123 = 0;
          $self->{itemTypes} = {};
          my $_ktype124 = 0;
          my $_vtype125 = 0;
          $xfer += $input->readMapBegin(\$_ktype124, \$_vtype125, \$_size123);
          for (my $_i127 = 0; $_i127 < $_size123; ++$_i127)
          {
            my $key128 = '';
            my $val129 = '';
            $xfer += $input->readString(\$key128);
            $xfer += $input->readString(\$val129);
            $self->{itemTypes}->{$key128} = $val129;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^8$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size130 = 0;
          $self->{displayItems} = [];
          my $_etype133 = 0;
          $xfer += $input->readListBegin(\$_etype133, \$_size130);
          for (my $_i134 = 0; $_i134 < $_size130; ++$_i134)
          {
            my $elem135 = undef;
            $xfer += $input->readString(\$elem135);
            push(@{$self->{displayItems}},$elem135);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^9$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{maxRatingVal});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^10$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{numRecs});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^11$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{recommenderName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^12$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{clientKey});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^13$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{homepage});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^14$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{creatorName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^15$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{repoName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^16$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^17$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{ratingsColumn});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecommenderService_updateTemplate_args');
  if (defined $self->{username}) {
    $xfer += $output->writeFieldBegin('username', TType::STRING, 1);
    $xfer += $output->writeString($self->{username});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{primaryKey}) {
    $xfer += $output->writeFieldBegin('primaryKey', TType::STRING, 2);
    $xfer += $output->writeString($self->{primaryKey});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{title}) {
    $xfer += $output->writeFieldBegin('title', TType::STRING, 3);
    $xfer += $output->writeString($self->{title});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{description}) {
    $xfer += $output->writeFieldBegin('description', TType::STRING, 4);
    $xfer += $output->writeString($self->{description});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{image}) {
    $xfer += $output->writeFieldBegin('image', TType::STRING, 5);
    $xfer += $output->writeString($self->{image});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{video}) {
    $xfer += $output->writeFieldBegin('video', TType::STRING, 6);
    $xfer += $output->writeString($self->{video});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{itemTypes}) {
    $xfer += $output->writeFieldBegin('itemTypes', TType::MAP, 7);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{itemTypes}}));
      {
        while( my ($kiter136,$viter137) = each %{$self->{itemTypes}}) 
        {
          $xfer += $output->writeString($kiter136);
          $xfer += $output->writeString($viter137);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{displayItems}) {
    $xfer += $output->writeFieldBegin('displayItems', TType::LIST, 8);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{displayItems}}));
      {
        foreach my $iter138 (@{$self->{displayItems}}) 
        {
          $xfer += $output->writeString($iter138);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{maxRatingVal}) {
    $xfer += $output->writeFieldBegin('maxRatingVal', TType::I64, 9);
    $xfer += $output->writeI64($self->{maxRatingVal});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{numRecs}) {
    $xfer += $output->writeFieldBegin('numRecs', TType::I64, 10);
    $xfer += $output->writeI64($self->{numRecs});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{recommenderName}) {
    $xfer += $output->writeFieldBegin('recommenderName', TType::STRING, 11);
    $xfer += $output->writeString($self->{recommenderName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{clientKey}) {
    $xfer += $output->writeFieldBegin('clientKey', TType::STRING, 12);
    $xfer += $output->writeString($self->{clientKey});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{homepage}) {
    $xfer += $output->writeFieldBegin('homepage', TType::STRING, 13);
    $xfer += $output->writeString($self->{homepage});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{creatorName}) {
    $xfer += $output->writeFieldBegin('creatorName', TType::STRING, 14);
    $xfer += $output->writeString($self->{creatorName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{repoName}) {
    $xfer += $output->writeFieldBegin('repoName', TType::STRING, 15);
    $xfer += $output->writeString($self->{repoName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 16);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ratingsColumn}) {
    $xfer += $output->writeFieldBegin('ratingsColumn', TType::STRING, 17);
    $xfer += $output->writeString($self->{ratingsColumn});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package kibitz::RecommenderService_updateTemplate_result;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'RecommenderService_updateTemplate_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecommenderService_updateTemplate_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package kibitz::RecommenderService_configurePrefilledUserRatings_args;
use base qw(Class::Accessor);
kibitz::RecommenderService_configurePrefilledUserRatings_args->mk_accessors( qw( username repoName primaryKey itemTable tableName userIdCol itemIdCol userRatingCol ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{username} = undef;
  $self->{repoName} = undef;
  $self->{primaryKey} = undef;
  $self->{itemTable} = undef;
  $self->{tableName} = undef;
  $self->{userIdCol} = undef;
  $self->{itemIdCol} = undef;
  $self->{userRatingCol} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{username}) {
      $self->{username} = $vals->{username};
    }
    if (defined $vals->{repoName}) {
      $self->{repoName} = $vals->{repoName};
    }
    if (defined $vals->{primaryKey}) {
      $self->{primaryKey} = $vals->{primaryKey};
    }
    if (defined $vals->{itemTable}) {
      $self->{itemTable} = $vals->{itemTable};
    }
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{userIdCol}) {
      $self->{userIdCol} = $vals->{userIdCol};
    }
    if (defined $vals->{itemIdCol}) {
      $self->{itemIdCol} = $vals->{itemIdCol};
    }
    if (defined $vals->{userRatingCol}) {
      $self->{userRatingCol} = $vals->{userRatingCol};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RecommenderService_configurePrefilledUserRatings_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{username});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{repoName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{primaryKey});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{itemTable});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{userIdCol});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{itemIdCol});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^8$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{userRatingCol});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecommenderService_configurePrefilledUserRatings_args');
  if (defined $self->{username}) {
    $xfer += $output->writeFieldBegin('username', TType::STRING, 1);
    $xfer += $output->writeString($self->{username});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{repoName}) {
    $xfer += $output->writeFieldBegin('repoName', TType::STRING, 2);
    $xfer += $output->writeString($self->{repoName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{primaryKey}) {
    $xfer += $output->writeFieldBegin('primaryKey', TType::STRING, 3);
    $xfer += $output->writeString($self->{primaryKey});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{itemTable}) {
    $xfer += $output->writeFieldBegin('itemTable', TType::STRING, 4);
    $xfer += $output->writeString($self->{itemTable});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 5);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userIdCol}) {
    $xfer += $output->writeFieldBegin('userIdCol', TType::STRING, 6);
    $xfer += $output->writeString($self->{userIdCol});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{itemIdCol}) {
    $xfer += $output->writeFieldBegin('itemIdCol', TType::STRING, 7);
    $xfer += $output->writeString($self->{itemIdCol});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userRatingCol}) {
    $xfer += $output->writeFieldBegin('userRatingCol', TType::STRING, 8);
    $xfer += $output->writeString($self->{userRatingCol});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package kibitz::RecommenderService_configurePrefilledUserRatings_result;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'RecommenderService_configurePrefilledUserRatings_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecommenderService_configurePrefilledUserRatings_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package kibitz::RecommenderService_getTables_args;
use base qw(Class::Accessor);
kibitz::RecommenderService_getTables_args->mk_accessors( qw( username repo ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{username} = undef;
  $self->{repo} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{username}) {
      $self->{username} = $vals->{username};
    }
    if (defined $vals->{repo}) {
      $self->{repo} = $vals->{repo};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RecommenderService_getTables_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{username});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{repo});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecommenderService_getTables_args');
  if (defined $self->{username}) {
    $xfer += $output->writeFieldBegin('username', TType::STRING, 1);
    $xfer += $output->writeString($self->{username});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{repo}) {
    $xfer += $output->writeFieldBegin('repo', TType::STRING, 2);
    $xfer += $output->writeString($self->{repo});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package kibitz::RecommenderService_getTables_result;
use base qw(Class::Accessor);
kibitz::RecommenderService_getTables_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RecommenderService_getTables_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size139 = 0;
          $self->{success} = [];
          my $_etype142 = 0;
          $xfer += $input->readListBegin(\$_etype142, \$_size139);
          for (my $_i143 = 0; $_i143 < $_size139; ++$_i143)
          {
            my $elem144 = undef;
            $xfer += $input->readString(\$elem144);
            push(@{$self->{success}},$elem144);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecommenderService_getTables_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter145 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter145);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package kibitz::RecommenderService_getColumns_args;
use base qw(Class::Accessor);
kibitz::RecommenderService_getColumns_args->mk_accessors( qw( username repo table ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{username} = undef;
  $self->{repo} = undef;
  $self->{table} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{username}) {
      $self->{username} = $vals->{username};
    }
    if (defined $vals->{repo}) {
      $self->{repo} = $vals->{repo};
    }
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RecommenderService_getColumns_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{username});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{repo});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecommenderService_getColumns_args');
  if (defined $self->{username}) {
    $xfer += $output->writeFieldBegin('username', TType::STRING, 1);
    $xfer += $output->writeString($self->{username});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{repo}) {
    $xfer += $output->writeFieldBegin('repo', TType::STRING, 2);
    $xfer += $output->writeString($self->{repo});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 3);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package kibitz::RecommenderService_getColumns_result;
use base qw(Class::Accessor);
kibitz::RecommenderService_getColumns_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RecommenderService_getColumns_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size146 = 0;
          $self->{success} = [];
          my $_etype149 = 0;
          $xfer += $input->readListBegin(\$_etype149, \$_size146);
          for (my $_i150 = 0; $_i150 < $_size146; ++$_i150)
          {
            my $elem151 = undef;
            $xfer += $input->readString(\$elem151);
            push(@{$self->{success}},$elem151);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecommenderService_getColumns_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter152 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter152);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package kibitz::RecommenderService_getFirstRepo_args;
use base qw(Class::Accessor);
kibitz::RecommenderService_getFirstRepo_args->mk_accessors( qw( username ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{username} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{username}) {
      $self->{username} = $vals->{username};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RecommenderService_getFirstRepo_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{username});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecommenderService_getFirstRepo_args');
  if (defined $self->{username}) {
    $xfer += $output->writeFieldBegin('username', TType::STRING, 1);
    $xfer += $output->writeString($self->{username});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package kibitz::RecommenderService_getFirstRepo_result;
use base qw(Class::Accessor);
kibitz::RecommenderService_getFirstRepo_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RecommenderService_getFirstRepo_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecommenderService_getFirstRepo_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package kibitz::RecommenderService_getNumRepos_args;
use base qw(Class::Accessor);
kibitz::RecommenderService_getNumRepos_args->mk_accessors( qw( username ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{username} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{username}) {
      $self->{username} = $vals->{username};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RecommenderService_getNumRepos_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{username});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecommenderService_getNumRepos_args');
  if (defined $self->{username}) {
    $xfer += $output->writeFieldBegin('username', TType::STRING, 1);
    $xfer += $output->writeString($self->{username});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package kibitz::RecommenderService_getNumRepos_result;
use base qw(Class::Accessor);
kibitz::RecommenderService_getNumRepos_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RecommenderService_getNumRepos_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecommenderService_getNumRepos_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I64, 0);
    $xfer += $output->writeI64($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package kibitz::RecommenderService_getAllRepos_args;
use base qw(Class::Accessor);
kibitz::RecommenderService_getAllRepos_args->mk_accessors( qw( username ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{username} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{username}) {
      $self->{username} = $vals->{username};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RecommenderService_getAllRepos_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{username});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecommenderService_getAllRepos_args');
  if (defined $self->{username}) {
    $xfer += $output->writeFieldBegin('username', TType::STRING, 1);
    $xfer += $output->writeString($self->{username});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package kibitz::RecommenderService_getAllRepos_result;
use base qw(Class::Accessor);
kibitz::RecommenderService_getAllRepos_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RecommenderService_getAllRepos_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size153 = 0;
          $self->{success} = [];
          my $_etype156 = 0;
          $xfer += $input->readListBegin(\$_etype156, \$_size153);
          for (my $_i157 = 0; $_i157 < $_size153; ++$_i157)
          {
            my $elem158 = undef;
            $xfer += $input->readString(\$elem158);
            push(@{$self->{success}},$elem158);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecommenderService_getAllRepos_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter159 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter159);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package kibitz::RecommenderService_saveCSSData_args;
use base qw(Class::Accessor);
kibitz::RecommenderService_saveCSSData_args->mk_accessors( qw( path data ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{path} = undef;
  $self->{data} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{path}) {
      $self->{path} = $vals->{path};
    }
    if (defined $vals->{data}) {
      $self->{data} = $vals->{data};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RecommenderService_saveCSSData_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{path});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{data});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecommenderService_saveCSSData_args');
  if (defined $self->{path}) {
    $xfer += $output->writeFieldBegin('path', TType::STRING, 1);
    $xfer += $output->writeString($self->{path});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{data}) {
    $xfer += $output->writeFieldBegin('data', TType::STRING, 2);
    $xfer += $output->writeString($self->{data});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package kibitz::RecommenderService_saveCSSData_result;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'RecommenderService_saveCSSData_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecommenderService_saveCSSData_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package kibitz::RecommenderServiceIf;

use strict;


sub createNewIndividualServer{
  my $self = shift;
  my $key = shift;

  die 'implement interface';
}

sub terminateSession{
  my $self = shift;
  my $key = shift;

  die 'implement interface';
}

sub makeRecommendation{
  my $self = shift;
  my $key = shift;
  my $userId = shift;
  my $numRecs = shift;
  my $isBoolean = shift;
  my $displayColumns = shift;

  die 'implement interface';
}

sub makeItemBasedRecommendations{
  my $self = shift;
  my $key = shift;
  my $userId = shift;
  my $numRecs = shift;
  my $displayColumns = shift;

  die 'implement interface';
}

sub getPageItems{
  my $self = shift;
  my $key = shift;
  my $page = shift;
  my $numPerPage = shift;
  my $displayColumns = shift;

  die 'implement interface';
}

sub getItemCount{
  my $self = shift;
  my $key = shift;

  die 'implement interface';
}

sub recordRatings{
  my $self = shift;
  my $key = shift;
  my $userId = shift;
  my $itemId = shift;
  my $rating = shift;

  die 'implement interface';
}

sub deleteRatings{
  my $self = shift;
  my $key = shift;
  my $userId = shift;
  my $itemId = shift;

  die 'implement interface';
}

sub createNewUser{
  my $self = shift;
  my $key = shift;
  my $username = shift;
  my $iskibitzuser = shift;

  die 'implement interface';
}

sub checkUsername{
  my $self = shift;
  my $key = shift;
  my $username = shift;
  my $iskibitzuser = shift;

  die 'implement interface';
}

sub checkLogin{
  my $self = shift;
  my $key = shift;
  my $username = shift;
  my $password = shift;
  my $iskibitzuser = shift;

  die 'implement interface';
}

sub retrieveUserId{
  my $self = shift;
  my $key = shift;
  my $username = shift;

  die 'implement interface';
}

sub createNewRecommender{
  my $self = shift;
  my $username = shift;
  my $primaryKey = shift;
  my $database = shift;
  my $table = shift;
  my $title = shift;
  my $description = shift;
  my $image = shift;
  my $ratings_column = shift;
  my $clientKey = shift;

  die 'implement interface';
}

sub getUserRatedItems{
  my $self = shift;
  my $key = shift;
  my $userId = shift;
  my $displayColumns = shift;

  die 'implement interface';
}

sub initiateModel{
  my $self = shift;
  my $key = shift;
  my $table = shift;
  my $username = shift;
  my $database = shift;

  die 'implement interface';
}

sub getSearchItems{
  my $self = shift;
  my $table = shift;
  my $query = shift;
  my $columnsToSearch = shift;
  my $displayColumns = shift;

  die 'implement interface';
}

sub makeOverallRatingBasedOrRandomRecommendation{
  my $self = shift;
  my $key = shift;
  my $ratingColumnName = shift;
  my $numRecs = shift;
  my $displayColumns = shift;

  die 'implement interface';
}

sub addKibitzUser{
  my $self = shift;
  my $email = shift;
  my $password = shift;

  die 'implement interface';
}

sub checkCorrectDatahubLogin{
  my $self = shift;
  my $username = shift;
  my $repository = shift;
  my $table = shift;
  my $primary_key = shift;
  my $title = shift;
  my $description = shift;
  my $image = shift;

  die 'implement interface';
}

sub checkRatingsColumn{
  my $self = shift;
  my $username = shift;
  my $table = shift;
  my $repository = shift;
  my $ratings_column = shift;

  die 'implement interface';
}

sub getRecommenders{
  my $self = shift;
  my $username = shift;

  die 'implement interface';
}

sub getProfilePicture{
  my $self = shift;
  my $username = shift;

  die 'implement interface';
}

sub saveFBProfilePic{
  my $self = shift;
  my $username = shift;
  my $fbUsername = shift;

  die 'implement interface';
}

sub deleteRecommender{
  my $self = shift;
  my $clientKey = shift;

  die 'implement interface';
}

sub updateTemplate{
  my $self = shift;
  my $username = shift;
  my $primaryKey = shift;
  my $title = shift;
  my $description = shift;
  my $image = shift;
  my $video = shift;
  my $itemTypes = shift;
  my $displayItems = shift;
  my $maxRatingVal = shift;
  my $numRecs = shift;
  my $recommenderName = shift;
  my $clientKey = shift;
  my $homepage = shift;
  my $creatorName = shift;
  my $repoName = shift;
  my $tableName = shift;
  my $ratingsColumn = shift;

  die 'implement interface';
}

sub configurePrefilledUserRatings{
  my $self = shift;
  my $username = shift;
  my $repoName = shift;
  my $primaryKey = shift;
  my $itemTable = shift;
  my $tableName = shift;
  my $userIdCol = shift;
  my $itemIdCol = shift;
  my $userRatingCol = shift;

  die 'implement interface';
}

sub getTables{
  my $self = shift;
  my $username = shift;
  my $repo = shift;

  die 'implement interface';
}

sub getColumns{
  my $self = shift;
  my $username = shift;
  my $repo = shift;
  my $table = shift;

  die 'implement interface';
}

sub getFirstRepo{
  my $self = shift;
  my $username = shift;

  die 'implement interface';
}

sub getNumRepos{
  my $self = shift;
  my $username = shift;

  die 'implement interface';
}

sub getAllRepos{
  my $self = shift;
  my $username = shift;

  die 'implement interface';
}

sub saveCSSData{
  my $self = shift;
  my $path = shift;
  my $data = shift;

  die 'implement interface';
}

package kibitz::RecommenderServiceRest;

use strict;


sub new {
  my ($classname, $impl) = @_;
  my $self     ={ impl => $impl };

  return bless($self,$classname);
}

sub createNewIndividualServer{
  my ($self, $request) = @_;

  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  return $self->{impl}->createNewIndividualServer($key);
}

sub terminateSession{
  my ($self, $request) = @_;

  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  return $self->{impl}->terminateSession($key);
}

sub makeRecommendation{
  my ($self, $request) = @_;

  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  my $userId = ($request->{'userId'}) ? $request->{'userId'} : undef;
  my $numRecs = ($request->{'numRecs'}) ? $request->{'numRecs'} : undef;
  my $isBoolean = ($request->{'isBoolean'}) ? $request->{'isBoolean'} : undef;
  my $displayColumns = ($request->{'displayColumns'}) ? $request->{'displayColumns'} : undef;
  return $self->{impl}->makeRecommendation($key, $userId, $numRecs, $isBoolean, $displayColumns);
}

sub makeItemBasedRecommendations{
  my ($self, $request) = @_;

  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  my $userId = ($request->{'userId'}) ? $request->{'userId'} : undef;
  my $numRecs = ($request->{'numRecs'}) ? $request->{'numRecs'} : undef;
  my $displayColumns = ($request->{'displayColumns'}) ? $request->{'displayColumns'} : undef;
  return $self->{impl}->makeItemBasedRecommendations($key, $userId, $numRecs, $displayColumns);
}

sub getPageItems{
  my ($self, $request) = @_;

  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  my $page = ($request->{'page'}) ? $request->{'page'} : undef;
  my $numPerPage = ($request->{'numPerPage'}) ? $request->{'numPerPage'} : undef;
  my $displayColumns = ($request->{'displayColumns'}) ? $request->{'displayColumns'} : undef;
  return $self->{impl}->getPageItems($key, $page, $numPerPage, $displayColumns);
}

sub getItemCount{
  my ($self, $request) = @_;

  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  return $self->{impl}->getItemCount($key);
}

sub recordRatings{
  my ($self, $request) = @_;

  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  my $userId = ($request->{'userId'}) ? $request->{'userId'} : undef;
  my $itemId = ($request->{'itemId'}) ? $request->{'itemId'} : undef;
  my $rating = ($request->{'rating'}) ? $request->{'rating'} : undef;
  return $self->{impl}->recordRatings($key, $userId, $itemId, $rating);
}

sub deleteRatings{
  my ($self, $request) = @_;

  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  my $userId = ($request->{'userId'}) ? $request->{'userId'} : undef;
  my $itemId = ($request->{'itemId'}) ? $request->{'itemId'} : undef;
  return $self->{impl}->deleteRatings($key, $userId, $itemId);
}

sub createNewUser{
  my ($self, $request) = @_;

  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  my $username = ($request->{'username'}) ? $request->{'username'} : undef;
  my $iskibitzuser = ($request->{'iskibitzuser'}) ? $request->{'iskibitzuser'} : undef;
  return $self->{impl}->createNewUser($key, $username, $iskibitzuser);
}

sub checkUsername{
  my ($self, $request) = @_;

  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  my $username = ($request->{'username'}) ? $request->{'username'} : undef;
  my $iskibitzuser = ($request->{'iskibitzuser'}) ? $request->{'iskibitzuser'} : undef;
  return $self->{impl}->checkUsername($key, $username, $iskibitzuser);
}

sub checkLogin{
  my ($self, $request) = @_;

  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  my $username = ($request->{'username'}) ? $request->{'username'} : undef;
  my $password = ($request->{'password'}) ? $request->{'password'} : undef;
  my $iskibitzuser = ($request->{'iskibitzuser'}) ? $request->{'iskibitzuser'} : undef;
  return $self->{impl}->checkLogin($key, $username, $password, $iskibitzuser);
}

sub retrieveUserId{
  my ($self, $request) = @_;

  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  my $username = ($request->{'username'}) ? $request->{'username'} : undef;
  return $self->{impl}->retrieveUserId($key, $username);
}

sub createNewRecommender{
  my ($self, $request) = @_;

  my $username = ($request->{'username'}) ? $request->{'username'} : undef;
  my $primaryKey = ($request->{'primaryKey'}) ? $request->{'primaryKey'} : undef;
  my $database = ($request->{'database'}) ? $request->{'database'} : undef;
  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  my $title = ($request->{'title'}) ? $request->{'title'} : undef;
  my $description = ($request->{'description'}) ? $request->{'description'} : undef;
  my $image = ($request->{'image'}) ? $request->{'image'} : undef;
  my $ratings_column = ($request->{'ratings_column'}) ? $request->{'ratings_column'} : undef;
  my $clientKey = ($request->{'clientKey'}) ? $request->{'clientKey'} : undef;
  return $self->{impl}->createNewRecommender($username, $primaryKey, $database, $table, $title, $description, $image, $ratings_column, $clientKey);
}

sub getUserRatedItems{
  my ($self, $request) = @_;

  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  my $userId = ($request->{'userId'}) ? $request->{'userId'} : undef;
  my $displayColumns = ($request->{'displayColumns'}) ? $request->{'displayColumns'} : undef;
  return $self->{impl}->getUserRatedItems($key, $userId, $displayColumns);
}

sub initiateModel{
  my ($self, $request) = @_;

  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  my $username = ($request->{'username'}) ? $request->{'username'} : undef;
  my $database = ($request->{'database'}) ? $request->{'database'} : undef;
  return $self->{impl}->initiateModel($key, $table, $username, $database);
}

sub getSearchItems{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  my $query = ($request->{'query'}) ? $request->{'query'} : undef;
  my $columnsToSearch = ($request->{'columnsToSearch'}) ? $request->{'columnsToSearch'} : undef;
  my $displayColumns = ($request->{'displayColumns'}) ? $request->{'displayColumns'} : undef;
  return $self->{impl}->getSearchItems($table, $query, $columnsToSearch, $displayColumns);
}

sub makeOverallRatingBasedOrRandomRecommendation{
  my ($self, $request) = @_;

  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  my $ratingColumnName = ($request->{'ratingColumnName'}) ? $request->{'ratingColumnName'} : undef;
  my $numRecs = ($request->{'numRecs'}) ? $request->{'numRecs'} : undef;
  my $displayColumns = ($request->{'displayColumns'}) ? $request->{'displayColumns'} : undef;
  return $self->{impl}->makeOverallRatingBasedOrRandomRecommendation($key, $ratingColumnName, $numRecs, $displayColumns);
}

sub addKibitzUser{
  my ($self, $request) = @_;

  my $email = ($request->{'email'}) ? $request->{'email'} : undef;
  my $password = ($request->{'password'}) ? $request->{'password'} : undef;
  return $self->{impl}->addKibitzUser($email, $password);
}

sub checkCorrectDatahubLogin{
  my ($self, $request) = @_;

  my $username = ($request->{'username'}) ? $request->{'username'} : undef;
  my $repository = ($request->{'repository'}) ? $request->{'repository'} : undef;
  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  my $primary_key = ($request->{'primary_key'}) ? $request->{'primary_key'} : undef;
  my $title = ($request->{'title'}) ? $request->{'title'} : undef;
  my $description = ($request->{'description'}) ? $request->{'description'} : undef;
  my $image = ($request->{'image'}) ? $request->{'image'} : undef;
  return $self->{impl}->checkCorrectDatahubLogin($username, $repository, $table, $primary_key, $title, $description, $image);
}

sub checkRatingsColumn{
  my ($self, $request) = @_;

  my $username = ($request->{'username'}) ? $request->{'username'} : undef;
  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  my $repository = ($request->{'repository'}) ? $request->{'repository'} : undef;
  my $ratings_column = ($request->{'ratings_column'}) ? $request->{'ratings_column'} : undef;
  return $self->{impl}->checkRatingsColumn($username, $table, $repository, $ratings_column);
}

sub getRecommenders{
  my ($self, $request) = @_;

  my $username = ($request->{'username'}) ? $request->{'username'} : undef;
  return $self->{impl}->getRecommenders($username);
}

sub getProfilePicture{
  my ($self, $request) = @_;

  my $username = ($request->{'username'}) ? $request->{'username'} : undef;
  return $self->{impl}->getProfilePicture($username);
}

sub saveFBProfilePic{
  my ($self, $request) = @_;

  my $username = ($request->{'username'}) ? $request->{'username'} : undef;
  my $fbUsername = ($request->{'fbUsername'}) ? $request->{'fbUsername'} : undef;
  return $self->{impl}->saveFBProfilePic($username, $fbUsername);
}

sub deleteRecommender{
  my ($self, $request) = @_;

  my $clientKey = ($request->{'clientKey'}) ? $request->{'clientKey'} : undef;
  return $self->{impl}->deleteRecommender($clientKey);
}

sub updateTemplate{
  my ($self, $request) = @_;

  my $username = ($request->{'username'}) ? $request->{'username'} : undef;
  my $primaryKey = ($request->{'primaryKey'}) ? $request->{'primaryKey'} : undef;
  my $title = ($request->{'title'}) ? $request->{'title'} : undef;
  my $description = ($request->{'description'}) ? $request->{'description'} : undef;
  my $image = ($request->{'image'}) ? $request->{'image'} : undef;
  my $video = ($request->{'video'}) ? $request->{'video'} : undef;
  my $itemTypes = ($request->{'itemTypes'}) ? $request->{'itemTypes'} : undef;
  my $displayItems = ($request->{'displayItems'}) ? $request->{'displayItems'} : undef;
  my $maxRatingVal = ($request->{'maxRatingVal'}) ? $request->{'maxRatingVal'} : undef;
  my $numRecs = ($request->{'numRecs'}) ? $request->{'numRecs'} : undef;
  my $recommenderName = ($request->{'recommenderName'}) ? $request->{'recommenderName'} : undef;
  my $clientKey = ($request->{'clientKey'}) ? $request->{'clientKey'} : undef;
  my $homepage = ($request->{'homepage'}) ? $request->{'homepage'} : undef;
  my $creatorName = ($request->{'creatorName'}) ? $request->{'creatorName'} : undef;
  my $repoName = ($request->{'repoName'}) ? $request->{'repoName'} : undef;
  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $ratingsColumn = ($request->{'ratingsColumn'}) ? $request->{'ratingsColumn'} : undef;
  return $self->{impl}->updateTemplate($username, $primaryKey, $title, $description, $image, $video, $itemTypes, $displayItems, $maxRatingVal, $numRecs, $recommenderName, $clientKey, $homepage, $creatorName, $repoName, $tableName, $ratingsColumn);
}

sub configurePrefilledUserRatings{
  my ($self, $request) = @_;

  my $username = ($request->{'username'}) ? $request->{'username'} : undef;
  my $repoName = ($request->{'repoName'}) ? $request->{'repoName'} : undef;
  my $primaryKey = ($request->{'primaryKey'}) ? $request->{'primaryKey'} : undef;
  my $itemTable = ($request->{'itemTable'}) ? $request->{'itemTable'} : undef;
  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $userIdCol = ($request->{'userIdCol'}) ? $request->{'userIdCol'} : undef;
  my $itemIdCol = ($request->{'itemIdCol'}) ? $request->{'itemIdCol'} : undef;
  my $userRatingCol = ($request->{'userRatingCol'}) ? $request->{'userRatingCol'} : undef;
  return $self->{impl}->configurePrefilledUserRatings($username, $repoName, $primaryKey, $itemTable, $tableName, $userIdCol, $itemIdCol, $userRatingCol);
}

sub getTables{
  my ($self, $request) = @_;

  my $username = ($request->{'username'}) ? $request->{'username'} : undef;
  my $repo = ($request->{'repo'}) ? $request->{'repo'} : undef;
  return $self->{impl}->getTables($username, $repo);
}

sub getColumns{
  my ($self, $request) = @_;

  my $username = ($request->{'username'}) ? $request->{'username'} : undef;
  my $repo = ($request->{'repo'}) ? $request->{'repo'} : undef;
  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  return $self->{impl}->getColumns($username, $repo, $table);
}

sub getFirstRepo{
  my ($self, $request) = @_;

  my $username = ($request->{'username'}) ? $request->{'username'} : undef;
  return $self->{impl}->getFirstRepo($username);
}

sub getNumRepos{
  my ($self, $request) = @_;

  my $username = ($request->{'username'}) ? $request->{'username'} : undef;
  return $self->{impl}->getNumRepos($username);
}

sub getAllRepos{
  my ($self, $request) = @_;

  my $username = ($request->{'username'}) ? $request->{'username'} : undef;
  return $self->{impl}->getAllRepos($username);
}

sub saveCSSData{
  my ($self, $request) = @_;

  my $path = ($request->{'path'}) ? $request->{'path'} : undef;
  my $data = ($request->{'data'}) ? $request->{'data'} : undef;
  return $self->{impl}->saveCSSData($path, $data);
}

package kibitz::RecommenderServiceClient;


use base qw(kibitz::RecommenderServiceIf);
sub new {
  my ($classname, $input, $output) = @_;
  my $self      = {};
  $self->{input}  = $input;
  $self->{output} = defined $output ? $output : $input;
  $self->{seqid}  = 0;
  return bless($self,$classname);
}

sub createNewIndividualServer{
  my $self = shift;
  my $key = shift;

    $self->send_createNewIndividualServer($key);
  $self->recv_createNewIndividualServer();
}

sub send_createNewIndividualServer{
  my $self = shift;
  my $key = shift;

  $self->{output}->writeMessageBegin('createNewIndividualServer', TMessageType::CALL, $self->{seqid});
  my $args = new kibitz::RecommenderService_createNewIndividualServer_args();
  $args->{key} = $key;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_createNewIndividualServer{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new kibitz::RecommenderService_createNewIndividualServer_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  return;
}
sub terminateSession{
  my $self = shift;
  my $key = shift;

    $self->send_terminateSession($key);
  $self->recv_terminateSession();
}

sub send_terminateSession{
  my $self = shift;
  my $key = shift;

  $self->{output}->writeMessageBegin('terminateSession', TMessageType::CALL, $self->{seqid});
  my $args = new kibitz::RecommenderService_terminateSession_args();
  $args->{key} = $key;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_terminateSession{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new kibitz::RecommenderService_terminateSession_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  return;
}
sub makeRecommendation{
  my $self = shift;
  my $key = shift;
  my $userId = shift;
  my $numRecs = shift;
  my $isBoolean = shift;
  my $displayColumns = shift;

    $self->send_makeRecommendation($key, $userId, $numRecs, $isBoolean, $displayColumns);
  return $self->recv_makeRecommendation();
}

sub send_makeRecommendation{
  my $self = shift;
  my $key = shift;
  my $userId = shift;
  my $numRecs = shift;
  my $isBoolean = shift;
  my $displayColumns = shift;

  $self->{output}->writeMessageBegin('makeRecommendation', TMessageType::CALL, $self->{seqid});
  my $args = new kibitz::RecommenderService_makeRecommendation_args();
  $args->{key} = $key;
  $args->{userId} = $userId;
  $args->{numRecs} = $numRecs;
  $args->{isBoolean} = $isBoolean;
  $args->{displayColumns} = $displayColumns;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_makeRecommendation{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new kibitz::RecommenderService_makeRecommendation_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "makeRecommendation failed: unknown result";
}
sub makeItemBasedRecommendations{
  my $self = shift;
  my $key = shift;
  my $userId = shift;
  my $numRecs = shift;
  my $displayColumns = shift;

    $self->send_makeItemBasedRecommendations($key, $userId, $numRecs, $displayColumns);
  return $self->recv_makeItemBasedRecommendations();
}

sub send_makeItemBasedRecommendations{
  my $self = shift;
  my $key = shift;
  my $userId = shift;
  my $numRecs = shift;
  my $displayColumns = shift;

  $self->{output}->writeMessageBegin('makeItemBasedRecommendations', TMessageType::CALL, $self->{seqid});
  my $args = new kibitz::RecommenderService_makeItemBasedRecommendations_args();
  $args->{key} = $key;
  $args->{userId} = $userId;
  $args->{numRecs} = $numRecs;
  $args->{displayColumns} = $displayColumns;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_makeItemBasedRecommendations{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new kibitz::RecommenderService_makeItemBasedRecommendations_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "makeItemBasedRecommendations failed: unknown result";
}
sub getPageItems{
  my $self = shift;
  my $key = shift;
  my $page = shift;
  my $numPerPage = shift;
  my $displayColumns = shift;

    $self->send_getPageItems($key, $page, $numPerPage, $displayColumns);
  return $self->recv_getPageItems();
}

sub send_getPageItems{
  my $self = shift;
  my $key = shift;
  my $page = shift;
  my $numPerPage = shift;
  my $displayColumns = shift;

  $self->{output}->writeMessageBegin('getPageItems', TMessageType::CALL, $self->{seqid});
  my $args = new kibitz::RecommenderService_getPageItems_args();
  $args->{key} = $key;
  $args->{page} = $page;
  $args->{numPerPage} = $numPerPage;
  $args->{displayColumns} = $displayColumns;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getPageItems{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new kibitz::RecommenderService_getPageItems_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "getPageItems failed: unknown result";
}
sub getItemCount{
  my $self = shift;
  my $key = shift;

    $self->send_getItemCount($key);
  return $self->recv_getItemCount();
}

sub send_getItemCount{
  my $self = shift;
  my $key = shift;

  $self->{output}->writeMessageBegin('getItemCount', TMessageType::CALL, $self->{seqid});
  my $args = new kibitz::RecommenderService_getItemCount_args();
  $args->{key} = $key;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getItemCount{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new kibitz::RecommenderService_getItemCount_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "getItemCount failed: unknown result";
}
sub recordRatings{
  my $self = shift;
  my $key = shift;
  my $userId = shift;
  my $itemId = shift;
  my $rating = shift;

    $self->send_recordRatings($key, $userId, $itemId, $rating);
  $self->recv_recordRatings();
}

sub send_recordRatings{
  my $self = shift;
  my $key = shift;
  my $userId = shift;
  my $itemId = shift;
  my $rating = shift;

  $self->{output}->writeMessageBegin('recordRatings', TMessageType::CALL, $self->{seqid});
  my $args = new kibitz::RecommenderService_recordRatings_args();
  $args->{key} = $key;
  $args->{userId} = $userId;
  $args->{itemId} = $itemId;
  $args->{rating} = $rating;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_recordRatings{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new kibitz::RecommenderService_recordRatings_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  return;
}
sub deleteRatings{
  my $self = shift;
  my $key = shift;
  my $userId = shift;
  my $itemId = shift;

    $self->send_deleteRatings($key, $userId, $itemId);
  $self->recv_deleteRatings();
}

sub send_deleteRatings{
  my $self = shift;
  my $key = shift;
  my $userId = shift;
  my $itemId = shift;

  $self->{output}->writeMessageBegin('deleteRatings', TMessageType::CALL, $self->{seqid});
  my $args = new kibitz::RecommenderService_deleteRatings_args();
  $args->{key} = $key;
  $args->{userId} = $userId;
  $args->{itemId} = $itemId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_deleteRatings{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new kibitz::RecommenderService_deleteRatings_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  return;
}
sub createNewUser{
  my $self = shift;
  my $key = shift;
  my $username = shift;
  my $iskibitzuser = shift;

    $self->send_createNewUser($key, $username, $iskibitzuser);
  return $self->recv_createNewUser();
}

sub send_createNewUser{
  my $self = shift;
  my $key = shift;
  my $username = shift;
  my $iskibitzuser = shift;

  $self->{output}->writeMessageBegin('createNewUser', TMessageType::CALL, $self->{seqid});
  my $args = new kibitz::RecommenderService_createNewUser_args();
  $args->{key} = $key;
  $args->{username} = $username;
  $args->{iskibitzuser} = $iskibitzuser;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_createNewUser{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new kibitz::RecommenderService_createNewUser_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "createNewUser failed: unknown result";
}
sub checkUsername{
  my $self = shift;
  my $key = shift;
  my $username = shift;
  my $iskibitzuser = shift;

    $self->send_checkUsername($key, $username, $iskibitzuser);
  return $self->recv_checkUsername();
}

sub send_checkUsername{
  my $self = shift;
  my $key = shift;
  my $username = shift;
  my $iskibitzuser = shift;

  $self->{output}->writeMessageBegin('checkUsername', TMessageType::CALL, $self->{seqid});
  my $args = new kibitz::RecommenderService_checkUsername_args();
  $args->{key} = $key;
  $args->{username} = $username;
  $args->{iskibitzuser} = $iskibitzuser;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_checkUsername{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new kibitz::RecommenderService_checkUsername_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "checkUsername failed: unknown result";
}
sub checkLogin{
  my $self = shift;
  my $key = shift;
  my $username = shift;
  my $password = shift;
  my $iskibitzuser = shift;

    $self->send_checkLogin($key, $username, $password, $iskibitzuser);
  return $self->recv_checkLogin();
}

sub send_checkLogin{
  my $self = shift;
  my $key = shift;
  my $username = shift;
  my $password = shift;
  my $iskibitzuser = shift;

  $self->{output}->writeMessageBegin('checkLogin', TMessageType::CALL, $self->{seqid});
  my $args = new kibitz::RecommenderService_checkLogin_args();
  $args->{key} = $key;
  $args->{username} = $username;
  $args->{password} = $password;
  $args->{iskibitzuser} = $iskibitzuser;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_checkLogin{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new kibitz::RecommenderService_checkLogin_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "checkLogin failed: unknown result";
}
sub retrieveUserId{
  my $self = shift;
  my $key = shift;
  my $username = shift;

    $self->send_retrieveUserId($key, $username);
  return $self->recv_retrieveUserId();
}

sub send_retrieveUserId{
  my $self = shift;
  my $key = shift;
  my $username = shift;

  $self->{output}->writeMessageBegin('retrieveUserId', TMessageType::CALL, $self->{seqid});
  my $args = new kibitz::RecommenderService_retrieveUserId_args();
  $args->{key} = $key;
  $args->{username} = $username;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_retrieveUserId{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new kibitz::RecommenderService_retrieveUserId_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "retrieveUserId failed: unknown result";
}
sub createNewRecommender{
  my $self = shift;
  my $username = shift;
  my $primaryKey = shift;
  my $database = shift;
  my $table = shift;
  my $title = shift;
  my $description = shift;
  my $image = shift;
  my $ratings_column = shift;
  my $clientKey = shift;

    $self->send_createNewRecommender($username, $primaryKey, $database, $table, $title, $description, $image, $ratings_column, $clientKey);
  return $self->recv_createNewRecommender();
}

sub send_createNewRecommender{
  my $self = shift;
  my $username = shift;
  my $primaryKey = shift;
  my $database = shift;
  my $table = shift;
  my $title = shift;
  my $description = shift;
  my $image = shift;
  my $ratings_column = shift;
  my $clientKey = shift;

  $self->{output}->writeMessageBegin('createNewRecommender', TMessageType::CALL, $self->{seqid});
  my $args = new kibitz::RecommenderService_createNewRecommender_args();
  $args->{username} = $username;
  $args->{primaryKey} = $primaryKey;
  $args->{database} = $database;
  $args->{table} = $table;
  $args->{title} = $title;
  $args->{description} = $description;
  $args->{image} = $image;
  $args->{ratings_column} = $ratings_column;
  $args->{clientKey} = $clientKey;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_createNewRecommender{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new kibitz::RecommenderService_createNewRecommender_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "createNewRecommender failed: unknown result";
}
sub getUserRatedItems{
  my $self = shift;
  my $key = shift;
  my $userId = shift;
  my $displayColumns = shift;

    $self->send_getUserRatedItems($key, $userId, $displayColumns);
  return $self->recv_getUserRatedItems();
}

sub send_getUserRatedItems{
  my $self = shift;
  my $key = shift;
  my $userId = shift;
  my $displayColumns = shift;

  $self->{output}->writeMessageBegin('getUserRatedItems', TMessageType::CALL, $self->{seqid});
  my $args = new kibitz::RecommenderService_getUserRatedItems_args();
  $args->{key} = $key;
  $args->{userId} = $userId;
  $args->{displayColumns} = $displayColumns;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getUserRatedItems{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new kibitz::RecommenderService_getUserRatedItems_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "getUserRatedItems failed: unknown result";
}
sub initiateModel{
  my $self = shift;
  my $key = shift;
  my $table = shift;
  my $username = shift;
  my $database = shift;

    $self->send_initiateModel($key, $table, $username, $database);
  $self->recv_initiateModel();
}

sub send_initiateModel{
  my $self = shift;
  my $key = shift;
  my $table = shift;
  my $username = shift;
  my $database = shift;

  $self->{output}->writeMessageBegin('initiateModel', TMessageType::CALL, $self->{seqid});
  my $args = new kibitz::RecommenderService_initiateModel_args();
  $args->{key} = $key;
  $args->{table} = $table;
  $args->{username} = $username;
  $args->{database} = $database;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_initiateModel{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new kibitz::RecommenderService_initiateModel_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  return;
}
sub getSearchItems{
  my $self = shift;
  my $table = shift;
  my $query = shift;
  my $columnsToSearch = shift;
  my $displayColumns = shift;

    $self->send_getSearchItems($table, $query, $columnsToSearch, $displayColumns);
  return $self->recv_getSearchItems();
}

sub send_getSearchItems{
  my $self = shift;
  my $table = shift;
  my $query = shift;
  my $columnsToSearch = shift;
  my $displayColumns = shift;

  $self->{output}->writeMessageBegin('getSearchItems', TMessageType::CALL, $self->{seqid});
  my $args = new kibitz::RecommenderService_getSearchItems_args();
  $args->{table} = $table;
  $args->{query} = $query;
  $args->{columnsToSearch} = $columnsToSearch;
  $args->{displayColumns} = $displayColumns;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getSearchItems{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new kibitz::RecommenderService_getSearchItems_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "getSearchItems failed: unknown result";
}
sub makeOverallRatingBasedOrRandomRecommendation{
  my $self = shift;
  my $key = shift;
  my $ratingColumnName = shift;
  my $numRecs = shift;
  my $displayColumns = shift;

    $self->send_makeOverallRatingBasedOrRandomRecommendation($key, $ratingColumnName, $numRecs, $displayColumns);
  return $self->recv_makeOverallRatingBasedOrRandomRecommendation();
}

sub send_makeOverallRatingBasedOrRandomRecommendation{
  my $self = shift;
  my $key = shift;
  my $ratingColumnName = shift;
  my $numRecs = shift;
  my $displayColumns = shift;

  $self->{output}->writeMessageBegin('makeOverallRatingBasedOrRandomRecommendation', TMessageType::CALL, $self->{seqid});
  my $args = new kibitz::RecommenderService_makeOverallRatingBasedOrRandomRecommendation_args();
  $args->{key} = $key;
  $args->{ratingColumnName} = $ratingColumnName;
  $args->{numRecs} = $numRecs;
  $args->{displayColumns} = $displayColumns;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_makeOverallRatingBasedOrRandomRecommendation{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new kibitz::RecommenderService_makeOverallRatingBasedOrRandomRecommendation_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "makeOverallRatingBasedOrRandomRecommendation failed: unknown result";
}
sub addKibitzUser{
  my $self = shift;
  my $email = shift;
  my $password = shift;

    $self->send_addKibitzUser($email, $password);
  $self->recv_addKibitzUser();
}

sub send_addKibitzUser{
  my $self = shift;
  my $email = shift;
  my $password = shift;

  $self->{output}->writeMessageBegin('addKibitzUser', TMessageType::CALL, $self->{seqid});
  my $args = new kibitz::RecommenderService_addKibitzUser_args();
  $args->{email} = $email;
  $args->{password} = $password;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_addKibitzUser{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new kibitz::RecommenderService_addKibitzUser_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  return;
}
sub checkCorrectDatahubLogin{
  my $self = shift;
  my $username = shift;
  my $repository = shift;
  my $table = shift;
  my $primary_key = shift;
  my $title = shift;
  my $description = shift;
  my $image = shift;

    $self->send_checkCorrectDatahubLogin($username, $repository, $table, $primary_key, $title, $description, $image);
  return $self->recv_checkCorrectDatahubLogin();
}

sub send_checkCorrectDatahubLogin{
  my $self = shift;
  my $username = shift;
  my $repository = shift;
  my $table = shift;
  my $primary_key = shift;
  my $title = shift;
  my $description = shift;
  my $image = shift;

  $self->{output}->writeMessageBegin('checkCorrectDatahubLogin', TMessageType::CALL, $self->{seqid});
  my $args = new kibitz::RecommenderService_checkCorrectDatahubLogin_args();
  $args->{username} = $username;
  $args->{repository} = $repository;
  $args->{table} = $table;
  $args->{primary_key} = $primary_key;
  $args->{title} = $title;
  $args->{description} = $description;
  $args->{image} = $image;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_checkCorrectDatahubLogin{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new kibitz::RecommenderService_checkCorrectDatahubLogin_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "checkCorrectDatahubLogin failed: unknown result";
}
sub checkRatingsColumn{
  my $self = shift;
  my $username = shift;
  my $table = shift;
  my $repository = shift;
  my $ratings_column = shift;

    $self->send_checkRatingsColumn($username, $table, $repository, $ratings_column);
  return $self->recv_checkRatingsColumn();
}

sub send_checkRatingsColumn{
  my $self = shift;
  my $username = shift;
  my $table = shift;
  my $repository = shift;
  my $ratings_column = shift;

  $self->{output}->writeMessageBegin('checkRatingsColumn', TMessageType::CALL, $self->{seqid});
  my $args = new kibitz::RecommenderService_checkRatingsColumn_args();
  $args->{username} = $username;
  $args->{table} = $table;
  $args->{repository} = $repository;
  $args->{ratings_column} = $ratings_column;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_checkRatingsColumn{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new kibitz::RecommenderService_checkRatingsColumn_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "checkRatingsColumn failed: unknown result";
}
sub getRecommenders{
  my $self = shift;
  my $username = shift;

    $self->send_getRecommenders($username);
  return $self->recv_getRecommenders();
}

sub send_getRecommenders{
  my $self = shift;
  my $username = shift;

  $self->{output}->writeMessageBegin('getRecommenders', TMessageType::CALL, $self->{seqid});
  my $args = new kibitz::RecommenderService_getRecommenders_args();
  $args->{username} = $username;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getRecommenders{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new kibitz::RecommenderService_getRecommenders_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "getRecommenders failed: unknown result";
}
sub getProfilePicture{
  my $self = shift;
  my $username = shift;

    $self->send_getProfilePicture($username);
  return $self->recv_getProfilePicture();
}

sub send_getProfilePicture{
  my $self = shift;
  my $username = shift;

  $self->{output}->writeMessageBegin('getProfilePicture', TMessageType::CALL, $self->{seqid});
  my $args = new kibitz::RecommenderService_getProfilePicture_args();
  $args->{username} = $username;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getProfilePicture{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new kibitz::RecommenderService_getProfilePicture_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "getProfilePicture failed: unknown result";
}
sub saveFBProfilePic{
  my $self = shift;
  my $username = shift;
  my $fbUsername = shift;

    $self->send_saveFBProfilePic($username, $fbUsername);
  $self->recv_saveFBProfilePic();
}

sub send_saveFBProfilePic{
  my $self = shift;
  my $username = shift;
  my $fbUsername = shift;

  $self->{output}->writeMessageBegin('saveFBProfilePic', TMessageType::CALL, $self->{seqid});
  my $args = new kibitz::RecommenderService_saveFBProfilePic_args();
  $args->{username} = $username;
  $args->{fbUsername} = $fbUsername;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_saveFBProfilePic{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new kibitz::RecommenderService_saveFBProfilePic_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  return;
}
sub deleteRecommender{
  my $self = shift;
  my $clientKey = shift;

    $self->send_deleteRecommender($clientKey);
  $self->recv_deleteRecommender();
}

sub send_deleteRecommender{
  my $self = shift;
  my $clientKey = shift;

  $self->{output}->writeMessageBegin('deleteRecommender', TMessageType::CALL, $self->{seqid});
  my $args = new kibitz::RecommenderService_deleteRecommender_args();
  $args->{clientKey} = $clientKey;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_deleteRecommender{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new kibitz::RecommenderService_deleteRecommender_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  return;
}
sub updateTemplate{
  my $self = shift;
  my $username = shift;
  my $primaryKey = shift;
  my $title = shift;
  my $description = shift;
  my $image = shift;
  my $video = shift;
  my $itemTypes = shift;
  my $displayItems = shift;
  my $maxRatingVal = shift;
  my $numRecs = shift;
  my $recommenderName = shift;
  my $clientKey = shift;
  my $homepage = shift;
  my $creatorName = shift;
  my $repoName = shift;
  my $tableName = shift;
  my $ratingsColumn = shift;

    $self->send_updateTemplate($username, $primaryKey, $title, $description, $image, $video, $itemTypes, $displayItems, $maxRatingVal, $numRecs, $recommenderName, $clientKey, $homepage, $creatorName, $repoName, $tableName, $ratingsColumn);
  $self->recv_updateTemplate();
}

sub send_updateTemplate{
  my $self = shift;
  my $username = shift;
  my $primaryKey = shift;
  my $title = shift;
  my $description = shift;
  my $image = shift;
  my $video = shift;
  my $itemTypes = shift;
  my $displayItems = shift;
  my $maxRatingVal = shift;
  my $numRecs = shift;
  my $recommenderName = shift;
  my $clientKey = shift;
  my $homepage = shift;
  my $creatorName = shift;
  my $repoName = shift;
  my $tableName = shift;
  my $ratingsColumn = shift;

  $self->{output}->writeMessageBegin('updateTemplate', TMessageType::CALL, $self->{seqid});
  my $args = new kibitz::RecommenderService_updateTemplate_args();
  $args->{username} = $username;
  $args->{primaryKey} = $primaryKey;
  $args->{title} = $title;
  $args->{description} = $description;
  $args->{image} = $image;
  $args->{video} = $video;
  $args->{itemTypes} = $itemTypes;
  $args->{displayItems} = $displayItems;
  $args->{maxRatingVal} = $maxRatingVal;
  $args->{numRecs} = $numRecs;
  $args->{recommenderName} = $recommenderName;
  $args->{clientKey} = $clientKey;
  $args->{homepage} = $homepage;
  $args->{creatorName} = $creatorName;
  $args->{repoName} = $repoName;
  $args->{tableName} = $tableName;
  $args->{ratingsColumn} = $ratingsColumn;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_updateTemplate{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new kibitz::RecommenderService_updateTemplate_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  return;
}
sub configurePrefilledUserRatings{
  my $self = shift;
  my $username = shift;
  my $repoName = shift;
  my $primaryKey = shift;
  my $itemTable = shift;
  my $tableName = shift;
  my $userIdCol = shift;
  my $itemIdCol = shift;
  my $userRatingCol = shift;

    $self->send_configurePrefilledUserRatings($username, $repoName, $primaryKey, $itemTable, $tableName, $userIdCol, $itemIdCol, $userRatingCol);
  $self->recv_configurePrefilledUserRatings();
}

sub send_configurePrefilledUserRatings{
  my $self = shift;
  my $username = shift;
  my $repoName = shift;
  my $primaryKey = shift;
  my $itemTable = shift;
  my $tableName = shift;
  my $userIdCol = shift;
  my $itemIdCol = shift;
  my $userRatingCol = shift;

  $self->{output}->writeMessageBegin('configurePrefilledUserRatings', TMessageType::CALL, $self->{seqid});
  my $args = new kibitz::RecommenderService_configurePrefilledUserRatings_args();
  $args->{username} = $username;
  $args->{repoName} = $repoName;
  $args->{primaryKey} = $primaryKey;
  $args->{itemTable} = $itemTable;
  $args->{tableName} = $tableName;
  $args->{userIdCol} = $userIdCol;
  $args->{itemIdCol} = $itemIdCol;
  $args->{userRatingCol} = $userRatingCol;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_configurePrefilledUserRatings{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new kibitz::RecommenderService_configurePrefilledUserRatings_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  return;
}
sub getTables{
  my $self = shift;
  my $username = shift;
  my $repo = shift;

    $self->send_getTables($username, $repo);
  return $self->recv_getTables();
}

sub send_getTables{
  my $self = shift;
  my $username = shift;
  my $repo = shift;

  $self->{output}->writeMessageBegin('getTables', TMessageType::CALL, $self->{seqid});
  my $args = new kibitz::RecommenderService_getTables_args();
  $args->{username} = $username;
  $args->{repo} = $repo;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getTables{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new kibitz::RecommenderService_getTables_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "getTables failed: unknown result";
}
sub getColumns{
  my $self = shift;
  my $username = shift;
  my $repo = shift;
  my $table = shift;

    $self->send_getColumns($username, $repo, $table);
  return $self->recv_getColumns();
}

sub send_getColumns{
  my $self = shift;
  my $username = shift;
  my $repo = shift;
  my $table = shift;

  $self->{output}->writeMessageBegin('getColumns', TMessageType::CALL, $self->{seqid});
  my $args = new kibitz::RecommenderService_getColumns_args();
  $args->{username} = $username;
  $args->{repo} = $repo;
  $args->{table} = $table;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getColumns{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new kibitz::RecommenderService_getColumns_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "getColumns failed: unknown result";
}
sub getFirstRepo{
  my $self = shift;
  my $username = shift;

    $self->send_getFirstRepo($username);
  return $self->recv_getFirstRepo();
}

sub send_getFirstRepo{
  my $self = shift;
  my $username = shift;

  $self->{output}->writeMessageBegin('getFirstRepo', TMessageType::CALL, $self->{seqid});
  my $args = new kibitz::RecommenderService_getFirstRepo_args();
  $args->{username} = $username;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getFirstRepo{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new kibitz::RecommenderService_getFirstRepo_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "getFirstRepo failed: unknown result";
}
sub getNumRepos{
  my $self = shift;
  my $username = shift;

    $self->send_getNumRepos($username);
  return $self->recv_getNumRepos();
}

sub send_getNumRepos{
  my $self = shift;
  my $username = shift;

  $self->{output}->writeMessageBegin('getNumRepos', TMessageType::CALL, $self->{seqid});
  my $args = new kibitz::RecommenderService_getNumRepos_args();
  $args->{username} = $username;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getNumRepos{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new kibitz::RecommenderService_getNumRepos_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "getNumRepos failed: unknown result";
}
sub getAllRepos{
  my $self = shift;
  my $username = shift;

    $self->send_getAllRepos($username);
  return $self->recv_getAllRepos();
}

sub send_getAllRepos{
  my $self = shift;
  my $username = shift;

  $self->{output}->writeMessageBegin('getAllRepos', TMessageType::CALL, $self->{seqid});
  my $args = new kibitz::RecommenderService_getAllRepos_args();
  $args->{username} = $username;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getAllRepos{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new kibitz::RecommenderService_getAllRepos_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "getAllRepos failed: unknown result";
}
sub saveCSSData{
  my $self = shift;
  my $path = shift;
  my $data = shift;

    $self->send_saveCSSData($path, $data);
  $self->recv_saveCSSData();
}

sub send_saveCSSData{
  my $self = shift;
  my $path = shift;
  my $data = shift;

  $self->{output}->writeMessageBegin('saveCSSData', TMessageType::CALL, $self->{seqid});
  my $args = new kibitz::RecommenderService_saveCSSData_args();
  $args->{path} = $path;
  $args->{data} = $data;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_saveCSSData{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new kibitz::RecommenderService_saveCSSData_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  return;
}
package kibitz::RecommenderServiceProcessor;

use strict;


sub new {
    my ($classname, $handler) = @_;
    my $self      = {};
    $self->{handler} = $handler;
    return bless ($self, $classname);
}

sub process {
    my ($self, $input, $output) = @_;
    my $rseqid = 0;
    my $fname  = undef;
    my $mtype  = 0;

    $input->readMessageBegin(\$fname, \$mtype, \$rseqid);
    my $methodname = 'process_'.$fname;
    if (!$self->can($methodname)) {
      $input->skip(TType::STRUCT);
      $input->readMessageEnd();
      my $x = new TApplicationException('Function '.$fname.' not implemented.', TApplicationException::UNKNOWN_METHOD);
      $output->writeMessageBegin($fname, TMessageType::EXCEPTION, $rseqid);
      $x->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      return;
    }
    $self->$methodname($rseqid, $input, $output);
    return 1;
}

sub process_createNewIndividualServer {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new kibitz::RecommenderService_createNewIndividualServer_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new kibitz::RecommenderService_createNewIndividualServer_result();
    $self->{handler}->createNewIndividualServer($args->key);
    $output->writeMessageBegin('createNewIndividualServer', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_terminateSession {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new kibitz::RecommenderService_terminateSession_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new kibitz::RecommenderService_terminateSession_result();
    $self->{handler}->terminateSession($args->key);
    $output->writeMessageBegin('terminateSession', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_makeRecommendation {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new kibitz::RecommenderService_makeRecommendation_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new kibitz::RecommenderService_makeRecommendation_result();
    $result->{success} = $self->{handler}->makeRecommendation($args->key, $args->userId, $args->numRecs, $args->isBoolean, $args->displayColumns);
    $output->writeMessageBegin('makeRecommendation', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_makeItemBasedRecommendations {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new kibitz::RecommenderService_makeItemBasedRecommendations_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new kibitz::RecommenderService_makeItemBasedRecommendations_result();
    $result->{success} = $self->{handler}->makeItemBasedRecommendations($args->key, $args->userId, $args->numRecs, $args->displayColumns);
    $output->writeMessageBegin('makeItemBasedRecommendations', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getPageItems {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new kibitz::RecommenderService_getPageItems_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new kibitz::RecommenderService_getPageItems_result();
    $result->{success} = $self->{handler}->getPageItems($args->key, $args->page, $args->numPerPage, $args->displayColumns);
    $output->writeMessageBegin('getPageItems', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getItemCount {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new kibitz::RecommenderService_getItemCount_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new kibitz::RecommenderService_getItemCount_result();
    $result->{success} = $self->{handler}->getItemCount($args->key);
    $output->writeMessageBegin('getItemCount', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_recordRatings {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new kibitz::RecommenderService_recordRatings_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new kibitz::RecommenderService_recordRatings_result();
    $self->{handler}->recordRatings($args->key, $args->userId, $args->itemId, $args->rating);
    $output->writeMessageBegin('recordRatings', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_deleteRatings {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new kibitz::RecommenderService_deleteRatings_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new kibitz::RecommenderService_deleteRatings_result();
    $self->{handler}->deleteRatings($args->key, $args->userId, $args->itemId);
    $output->writeMessageBegin('deleteRatings', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_createNewUser {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new kibitz::RecommenderService_createNewUser_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new kibitz::RecommenderService_createNewUser_result();
    $result->{success} = $self->{handler}->createNewUser($args->key, $args->username, $args->iskibitzuser);
    $output->writeMessageBegin('createNewUser', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_checkUsername {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new kibitz::RecommenderService_checkUsername_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new kibitz::RecommenderService_checkUsername_result();
    $result->{success} = $self->{handler}->checkUsername($args->key, $args->username, $args->iskibitzuser);
    $output->writeMessageBegin('checkUsername', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_checkLogin {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new kibitz::RecommenderService_checkLogin_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new kibitz::RecommenderService_checkLogin_result();
    $result->{success} = $self->{handler}->checkLogin($args->key, $args->username, $args->password, $args->iskibitzuser);
    $output->writeMessageBegin('checkLogin', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_retrieveUserId {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new kibitz::RecommenderService_retrieveUserId_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new kibitz::RecommenderService_retrieveUserId_result();
    $result->{success} = $self->{handler}->retrieveUserId($args->key, $args->username);
    $output->writeMessageBegin('retrieveUserId', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_createNewRecommender {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new kibitz::RecommenderService_createNewRecommender_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new kibitz::RecommenderService_createNewRecommender_result();
    $result->{success} = $self->{handler}->createNewRecommender($args->username, $args->primaryKey, $args->database, $args->table, $args->title, $args->description, $args->image, $args->ratings_column, $args->clientKey);
    $output->writeMessageBegin('createNewRecommender', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getUserRatedItems {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new kibitz::RecommenderService_getUserRatedItems_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new kibitz::RecommenderService_getUserRatedItems_result();
    $result->{success} = $self->{handler}->getUserRatedItems($args->key, $args->userId, $args->displayColumns);
    $output->writeMessageBegin('getUserRatedItems', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_initiateModel {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new kibitz::RecommenderService_initiateModel_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new kibitz::RecommenderService_initiateModel_result();
    $self->{handler}->initiateModel($args->key, $args->table, $args->username, $args->database);
    $output->writeMessageBegin('initiateModel', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getSearchItems {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new kibitz::RecommenderService_getSearchItems_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new kibitz::RecommenderService_getSearchItems_result();
    $result->{success} = $self->{handler}->getSearchItems($args->table, $args->query, $args->columnsToSearch, $args->displayColumns);
    $output->writeMessageBegin('getSearchItems', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_makeOverallRatingBasedOrRandomRecommendation {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new kibitz::RecommenderService_makeOverallRatingBasedOrRandomRecommendation_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new kibitz::RecommenderService_makeOverallRatingBasedOrRandomRecommendation_result();
    $result->{success} = $self->{handler}->makeOverallRatingBasedOrRandomRecommendation($args->key, $args->ratingColumnName, $args->numRecs, $args->displayColumns);
    $output->writeMessageBegin('makeOverallRatingBasedOrRandomRecommendation', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_addKibitzUser {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new kibitz::RecommenderService_addKibitzUser_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new kibitz::RecommenderService_addKibitzUser_result();
    $self->{handler}->addKibitzUser($args->email, $args->password);
    $output->writeMessageBegin('addKibitzUser', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_checkCorrectDatahubLogin {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new kibitz::RecommenderService_checkCorrectDatahubLogin_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new kibitz::RecommenderService_checkCorrectDatahubLogin_result();
    $result->{success} = $self->{handler}->checkCorrectDatahubLogin($args->username, $args->repository, $args->table, $args->primary_key, $args->title, $args->description, $args->image);
    $output->writeMessageBegin('checkCorrectDatahubLogin', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_checkRatingsColumn {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new kibitz::RecommenderService_checkRatingsColumn_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new kibitz::RecommenderService_checkRatingsColumn_result();
    $result->{success} = $self->{handler}->checkRatingsColumn($args->username, $args->table, $args->repository, $args->ratings_column);
    $output->writeMessageBegin('checkRatingsColumn', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getRecommenders {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new kibitz::RecommenderService_getRecommenders_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new kibitz::RecommenderService_getRecommenders_result();
    $result->{success} = $self->{handler}->getRecommenders($args->username);
    $output->writeMessageBegin('getRecommenders', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getProfilePicture {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new kibitz::RecommenderService_getProfilePicture_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new kibitz::RecommenderService_getProfilePicture_result();
    $result->{success} = $self->{handler}->getProfilePicture($args->username);
    $output->writeMessageBegin('getProfilePicture', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_saveFBProfilePic {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new kibitz::RecommenderService_saveFBProfilePic_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new kibitz::RecommenderService_saveFBProfilePic_result();
    $self->{handler}->saveFBProfilePic($args->username, $args->fbUsername);
    $output->writeMessageBegin('saveFBProfilePic', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_deleteRecommender {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new kibitz::RecommenderService_deleteRecommender_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new kibitz::RecommenderService_deleteRecommender_result();
    $self->{handler}->deleteRecommender($args->clientKey);
    $output->writeMessageBegin('deleteRecommender', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_updateTemplate {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new kibitz::RecommenderService_updateTemplate_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new kibitz::RecommenderService_updateTemplate_result();
    $self->{handler}->updateTemplate($args->username, $args->primaryKey, $args->title, $args->description, $args->image, $args->video, $args->itemTypes, $args->displayItems, $args->maxRatingVal, $args->numRecs, $args->recommenderName, $args->clientKey, $args->homepage, $args->creatorName, $args->repoName, $args->tableName, $args->ratingsColumn);
    $output->writeMessageBegin('updateTemplate', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_configurePrefilledUserRatings {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new kibitz::RecommenderService_configurePrefilledUserRatings_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new kibitz::RecommenderService_configurePrefilledUserRatings_result();
    $self->{handler}->configurePrefilledUserRatings($args->username, $args->repoName, $args->primaryKey, $args->itemTable, $args->tableName, $args->userIdCol, $args->itemIdCol, $args->userRatingCol);
    $output->writeMessageBegin('configurePrefilledUserRatings', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getTables {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new kibitz::RecommenderService_getTables_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new kibitz::RecommenderService_getTables_result();
    $result->{success} = $self->{handler}->getTables($args->username, $args->repo);
    $output->writeMessageBegin('getTables', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getColumns {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new kibitz::RecommenderService_getColumns_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new kibitz::RecommenderService_getColumns_result();
    $result->{success} = $self->{handler}->getColumns($args->username, $args->repo, $args->table);
    $output->writeMessageBegin('getColumns', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getFirstRepo {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new kibitz::RecommenderService_getFirstRepo_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new kibitz::RecommenderService_getFirstRepo_result();
    $result->{success} = $self->{handler}->getFirstRepo($args->username);
    $output->writeMessageBegin('getFirstRepo', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getNumRepos {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new kibitz::RecommenderService_getNumRepos_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new kibitz::RecommenderService_getNumRepos_result();
    $result->{success} = $self->{handler}->getNumRepos($args->username);
    $output->writeMessageBegin('getNumRepos', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getAllRepos {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new kibitz::RecommenderService_getAllRepos_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new kibitz::RecommenderService_getAllRepos_result();
    $result->{success} = $self->{handler}->getAllRepos($args->username);
    $output->writeMessageBegin('getAllRepos', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_saveCSSData {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new kibitz::RecommenderService_saveCSSData_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new kibitz::RecommenderService_saveCSSData_result();
    $self->{handler}->saveCSSData($args->path, $args->data);
    $output->writeMessageBegin('saveCSSData', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

1;
